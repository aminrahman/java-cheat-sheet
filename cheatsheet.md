<div dir="rtl">

## فهرست مطالب

- [Software Design Principals](#software-design-principals)
- [ORM or Object Relational Mapping](#orm-or-object-relational-mapping)
- [Authentication and Authorization](#authentication-and-authorization)
- [Project Management in Software Engineering](#project-management-in-software-engineering)
- [Scrum](#scrum)
- [Docker](#docker)
- [Cloud](#cloud)
- [Messaging Architecture](#messaging-architecture)
- [Git](#git)
- [Project Build Tools](#project-build-tools)
- [Cache Memory](#cache-memory)
- [Reflection](#reflection)
- [Data Structure in Java](#data-structure-in-java)
- [Search and Sort Algorithms](#search-and-sort-algorithms)
- [ReST vs. SOAP](#rest-vs-soap)
- [Different Types of Software Test](#different-types-of-software-test)
- [Monitoring Tools](#monitoring-tools)
- [Collection vs. Collections in java.util](#collection-vs-collections-in-javautil)
- [Instance Variable vs. Static Variable](#instance-variable-vs-static-variable)
- [== vs. equals in Java](#-vs-equals-in-java)
- [hashCode besides equals](#hashcode-besides-equals)
- [Thread and Synchronized](#thread-and-synchronized)
- [Scalable System Design Principals](#scalable-system-design-principals)
- [Index in Database](#index-in-database)
- [Singleton problem in Multi-thread environment](#singleton-problem-in-multi-thread-environment)
- [Serialization in distributed environment](#serialization-in-distributed-environment)
- [Techniques for Resource Management and Concurrency in Java](#techniques-for-resource-management-and-concurrency-in-java)


## Software Design Principals

- قانون Kiss (Keep It Simple, Stuid):
  - کدت رو ساده نگه‌دار و زیاد پیچیدش نکن.
  - کد باید تا حد امکان ساده نوشته بشه تا راحت فهمیده، تست، نگهداری و گسترش داده بشه.
  - توابع کوچک داشته باش. هر تابع باید فقط یک کار انجام بده.
  - از شرط‌های تودرتو پرهیز کن و شرط‌های ساده و واضح بنویس.
  - از متغیر اضافی پرهیز کن. متغیر اضافی پیچیدگی اضافی بهت تحمیل می‌کنه.
  - کد ساده‌تر تست پذیری راحت‌تری هم داره.
  - نام گذاری ها واضح باشن. اسم خوب خودش نصف توضیحاته.
  - در کل بدون هر کسی میتونه کد پیچیده‌ای بنویسه که کار میکنه مهم اینه کدی بنویسی که هم ساده باشه هم کار کنه.
  - قانون DRY (Don’t Repeat Yourself):
  - از تکرار کد خودداری کن.
    - تکرار = دردسر در نگهداری
    - در کل بهتره یک تابع یا کلاس مشترک بسازی
    - قانون YAGNI (You Are’nt Gonna Need It)":
    - چیزی رو که الان نیاز نداری اضافه نکن.
    - این که بگی شاید بعدا لازم شد = کد اضافی = پیچیدگی بیشتر
      - فقط چیزی رو بساز که واقعا لازم داری
  - قانون TDA (Tell, Don’t Ask):
  - به جای این که از شی چیزی بپرسی و بعد تصمیم بگیری، تصمیم رو به خودش بسپار و ازش کاری که میخوای انجام بده رو بخواه.
    - یه مثال:

<div dir="ltr">

```
if (car.getFuelLevel() > 0) {
	car.drive();
} //Wrong way

car.drive(); //Correct way
```

</div>

- قانون SOLID (Single responsibility, Opne/Closed, Liskov substitution, Interface Segregation, Dependency Injection):

  - S: Single Responsibility  هر کلاس باید فقط یک وظیفه داشته باشد. مثال احراز هویت و ریپازیتوری در یک کلاس
  - O: Open/Closed  کلاس‌ها باید برای توسعه باز و برای تغییر بسته باشند. مثال مستطیل و اضافه شدن دایره برای محاسبه مساحت.
  - L: Liskov Substitution اشیاء فرزند باید قابل جایگزینی با والد باشند. مثال پرنده و پنگوئن.
  - I: Interface Segregation نباید مجبور به پیاده‌سازی متدهایی شویم که نیاز نداریم. مثال کارگر که هم ربات پیاده ش کنه هم انسان (کار کردن و خوردن)
  - D: Dependency Inversion وابستگی‌ها باید به abstraction باشد، نه پیاده‌سازی. مثال وابستگی سوییچ به لامپ. باید به دیوایس وابسته باشه.
- قانون GRASP (General Reponsibility Assignment Software Pattern):

  - این قوانین الگوهای کلی برای واگذاری مسئولیت‌ها در طراحی شی گرا هستند.
  - این اصول به ما کمک میکنند تصمیم بگیریم کدام کلاس/شی باید چه مسئولیتی داشته باشد.
  - درواقع SOLID میگه چطور طراحی کنیم و GRASP میگه چه کسی (شی/کلاس) چیکار کنه.
  - شامل موارد زیر هست:

    - Information Expert: کلاسی مسئولیت رو بگیره که بیشترین اطلاعات مرتبط رو داره. مثلا کلاس Invoice باید جمع قیمت آیتم هارو محاسبه کنه چون خودش به آیتم ها دسترسی داره.
    - Creator: کلاسی شیء جدید بسازی که با اون رابطه نزدیک داره. مثلا کلاس Order بیاد OrderItem بسازه چون هر Order شامل OrderItemها هست.
    - Controller: کلاس بین UI و جدول هست که ورودی‌ها رو کنترل میکنه. مثلا در MVC میتونیم OrderController داشته باشیم.
    - Low Coupling: وابستگی بین کلاس‌ها باید تا جای ممکن کم باشه. مثلا به جای این که کلاس A مستقیما کلاس B رو بسازی، از Factory یا Dependenci Injection استفاده کنه.
    - High Cohision: هر کلاسی باید یه کار مشخص تمیز داشته باشه. کلاسی که کارهای پراکنده میکنه قابل نگهداری نیست.
    - Polymorphism: به معنای داشتن رفتار متفاوت با استفاه از Interface هست. مثلا میتونیم از Animal به عنوان اینترفیس استفاده کنیم که تابع Speak داره و بعد سگ و گربه اون رو پیاده میکنند.
    - Pure Fabrication: یک کلاس مصنوعی بساز فقط برای رعایت بقیه اصول. مثلا repository برای جدا کردن دسترسی به دیتابیس در مدل اصلی.
    - Indirection: ایجاد یک واسطه برای کاهش وابستگی سیستم. مثلا استفاده از سرویس یا اینترفیس بین Controller و Data Access
    - Protected Variations: نقاطی که ممکنه تغییر کنند رو با abstraction بپوشون. مثلا استفاده از اینترفیس برای لایه دیتابیس چون ممکنه نوع دیتابیس عوض بشه.

## ORM or Object Relational Mapping

- تبدیل خودکار بین اشیاء برنامه (Objects) و جداول پایگاه داده (Relational Table) را انجام می‌دهد.
- یک ابزار یا به عبارتی یک کتابخانه است که کمک می‌کند به جای نوشتن مستقیم SQL خام، از طریق کلاس‌ها و اشیاء جاوا با دیتابیس کار کنیم.
- معروف تریم ORM در جاوا Hibernate است.
- JPA هم یک استاندارد جاوا برای ORM است و هایبرنیت به عبارتی یکی از پیاده سازی های JPA  است.
- Spring Data JPA هم یک ابسترکت بالاتر روی JPA است و برای راحتی بیشتر است. کار راه راحت تر و امن تر کرده و قابلیت نگهداری را افزایش می دهد اما برای کوئری های پیچیده بهتر است از SQL استفاده شود.
- انواع کارکردها و نیازهاشون:
  - برای CRUD ساده و معمولی: ORM عالیه
  - برای پروژه های بزرگ و تیمی: ORM برای نگهداری بهتره
  - در صورت نیاز به پرفورمنس بالا: SQL خام در برخی بخش‌های خاص بهتره
  - برای گزارش‌گیری سنگین و پیچیده: SQL یا Stored Procedure مفید تره
- نمونه SP:

<div dir="ltr">

```
@NamedStoredProcedureQuery(
    name = "getEmployeesByDepartment",
    procedureName = "GET_EMPLOYEES_BY_DEPT",
    parameters = {
        @StoredProcedureParameter(mode = ParameterMode.IN, name = "deptId", type = Integer.class)
    },
    resultClasses = Employee.class
)
@Entity
public class Employee {
    // ...
}
```

</div>

و سپس در کد:

<div dir="ltr">

```
StoredProcedureQuery query = entityManager
    .createNamedStoredProcedureQuery("getEmployeesByDepartment")
    .setParameter("deptId", 10);
List<Employee> employees = query.getResultList();
```

</div>

- Annotationهای پایه در هایبرنیت برای نگاشت کلاس به جدول:
  - @Entity: کلاس نماینده یک جدول است.
  - @Table: نام جدول رو در دیتابیس مشخص میکند.
  - @Id: مشخص کننده کلید اصلی یا همان Primary Key است.
  - @GeneratedValue: نحوه تولید مقدار کلید اصلی را مشخص می‌کند.
  - @Column: نام یک ستون خاص در جدول را مشخص میکند.
  - Annotationهای پایه برای نگاشت روابط بین جداول (ارتباط بین کلاس‌ها):
  - برای روابط یک به یک، یک به چند و چند به یک @JoinColumn که ستون کلید خارجی را مشخص میکند.
  - برای روابط چند به چند @JoinTable که جدول واسط را مشخص میکند.
- Annotationهای مربوط به ویژگی ستون‌ها:
  - @Column مشخص می‌کند که یک فیلد به یک ستون در جدول پایگاه داده نگاشت شود. قابلیت تنظیم ویژگی‌هایی مثل name, nullable, length, unique و columnDefinition را دارد.

<div dir="ltr">

```
@Column(name = "first_name", nullable = false, length = 50)
private String firstName;
```

</div>

- @Temporal فقط برای فیلدهای نوع java.util.Date یا Calendar استفاده می‌شود. تعیین می‌کند که کدام بخش از زمان (تاریخ/ساعت/هر دو) در پایگاه داده ذخیره شود. مقادیر ممکن: TemporalType.DATE, TemporalType.TIME, TemporalType.TIMESTAMP.

<div dir="ltr">

```
@Temporal(TemporalType.DATE)
private Date birthDate;
```

</div>

- @Lob برای فیلدهایی با حجم بالا استفاده می‌شود (مثل متن‌های طولانی یا داده‌های باینری). متن بزرگ (CLOB) یا داده باینری بزرگ (BLOB) را مشخص می‌کند.

<div dir="ltr">

```
@Lob
private String longText;

@Lob
private byte[] imageData;
```

</div>

- @Transient این فیلد در پایگاه داده ذخیره نمی‌شود. برای داده‌هایی استفاده می‌شود که فقط در حافظه نگهداری می‌شوند (مثلاً برای محاسبات موقت). مشابه transient در جاوا ولی مخصوص JPA است.

<div dir="ltr">

```
@Transient
private String tempDisplayName;
```

</div>

- نحوه کار به این صورته که زمانی که هایبرنیت شروع به کار میکنه، کلاس هایی که انوتیشن @Entity دارند رو شناسایی میکنه . براشون جدول معادل در دیتابیس ایجاد میکنه (در صورت استفاده از auto-schema-generator) اطلاعات موجود در جدول رو به شیء جاوا و برعکس نگاشت میکنه.
  مقایسه کلید اولیه یا Primary Key با کلید خارجی یا Foreign Key:


|               ویژگی | PK                                      | FK                                         |
| -------------------------: | ----------------------------------------- | -------------------------------------------- |
|               تعریف | شناسه یکتای ردیف جدول | ایجاد ارتباط بین جداول  |
|        یکتا بودن | باید یکتا باشد              | می تواند تکراری باشد      |
|        Nullable بودن | خیر                                  | ممکن است (بسته به نیاز)   |
| تعداد در جدول | فقط یکی                           | می تواند چندتا باشد        |
|           وابستگی | مستقل است                       | به جدول دیگر وابسته است |

## Authentication and Authorization


|      مفاهیم |                                          Authentication |                                                  Authorization |
| ------------------: | --------------------------------------------------------: | ---------------------------------------------------------------: |
|          معنی |                                     احراز هویت |                                          مجوز دسترسی |
| سوال اصلی |                                    تو کی هستی؟ | اجازه دسترسی به چه چیزایی رو داری؟ |
|            هدف |                          تأیید هویت کاربر |                                 تعیین سطح دسترسی |
|        ترتیب |                              اول انجام میشه |            بعد از احراز هویت انجام میشه |
|          مثال | وارد کردن نام کاربری و گذرواژه |  اجازه دیدن، ویرایش یا حذف اطلاعات |

- روش های رایج احراز هویت

  - User/Pass
  - ایمیل یا پیامک (OTP)
  - اثر انگشت یا تشخیص چهره
  - Token (مثل JWT)
- یک روال معمول در احراز هویت و تعیین دسترسی:

  - APIGateway -> Auth Service (login/jwt/token validation) -> Policy Service (roles/permissions/rules) -> Other microservice check access
- دو نوع کنترل دسترسی:

  - RBAC یا Role-Based Access Control: کنترل دسترسی براساس نقش اتفاق می افتد. مثلا نقش Admin اجازه حذف یک داده را دارد ولی نقش User ندارد.
  - ABAC یا  Attribute-Based Access Control: کنترل دسترسی براساس ویژگی اتفاق می افتد. مثلا اگر دپارتمان یک یوزر منابع انسانی بود، می تواند در بازه ساعت 8 تا 10 تغییراتی را اعمال کند.
- Json Web Token یا JWT

  - یک توکن سبک، رمزنگاری شده و قابل حمل که اطلاعات عضویت و دسترسی کاربران را در خود نگهداری میکند. کاربرد اصلی JWT در احراز هویت در اپلیکیشنهای مختلف مانند وب، موبایل و APIهای Restful است.
  - سه بخش دارد:

    - Header که نوع توکن و الگوریتم های رمزنگاری را مشخص میکند.
    - Payload
    - Signiture
  - برخی از مزایای JWT:

    - بی نیاز اس سشن است. به این معنا که اطلاعات داخل خود توکن ذخیره می شود و نیازی به نگهداری سشن در سمت سرور نیست و اصطلاحا Stateless است (در مقابل Stateful)
    - مقیاس‌پذیری را بیشتر میکند چون سرورها سشن ذخیره نمیکنند و به راحتی میشه چند سرور همزمان داشت.
    - امن است. اگر به درستی و با استفاده از HTTPS و کلید محرمانه قوی پیاده شود، امنیت بسیار بالایی دارد.
    - در APIها چون Stateless هستند به راحتی قابل استفاده هستند
  - نکات امنیتی:

    - همیشه از HTTPs استفاده کن
    - توکنها رو در HTTP Only Cookie یا Secure Storage قرار بده
    - زمان انقضا یا Expiration کوتاه تنظیم کن و از رفرش توکن برای تجدید توکن استفاده کن

## Project Management in Software Engineering

- Waterfall: فرایند آبشاری یک فرایند خطی و مرحله ای است. هر مرحله (تحلیل، پیاده سازی و آزمون) باید به طور کامل تمام شود تا به مرحله بعدی برود. در این روش تغییر در مرحله قبل سخت و هزینه بر است.
- Agile: فرایند چابک فرایندی تدریجی و تکرارشونده است. پروژه به بخش های کوچکی به نام اسپرینت تقسیم می شود که مثلا به طول دو یا سه هفته هستند. در این روش، در هر چرخه بازخورد مشتری دریافت شده و قابلیت تغییر سریع در پروژه وجود دارد.

## Scrum

- نقش‌های اصلی در اسکرام:

  - Product Owner یا PO: مالک محصول است و نقش تجاری یا Business Role محسوب می شود. PO درواقع نماینده مشتری و ذینفعان است و مشخص می‌کند چه چیزی ساخته شود (What to build). مالک محصول مدیریت و اولویت بندی وظایف مربوط به پروژه را انجام می دهد و Backlog محصول را به روز نگه میدارد. بر ارزش محصول و نیاز بازار تمرکز دارد. مثلا ممکن است تصمیم بگیرد که اول سیستم پرداخت آنلاین توسعه داده شود چون ارزش تجاری بیشتری دارد.
  - در کنار PO تیم فنی را داریم که شامل نقش فنی یا Technical Role می شود. این تیم تیم توسعه است. یک تیم خودگردان که وظیفه اش ساختن محصول است. این تیم شامل برنامه نویس، طراح، تستر و DevOps است. این تیم تصمیم می‌گیرد محصول چگونه ساخته شود (How to build). در هر اسپرینت، راهبر فنی و تیم فنی آیتم‌هایی رو از Backlog انتخاب می کنند و توسعه می ‌دهند. مثلا این تیم در بخش پرداخت تصمیم می‌گیره پروژه با استفاده از Spring Boot و به صورت NoSQL نوشته بشه.
  - در کنار این ها نقش Scrum Master رو داریم که نقش خدمت گذار یا تسهیل گرد رو داره. این نقش محافظ چارچوب اسکرام هست و کمک میکند فرآیندها کاملا روان و طبق اصول اسکرام پیش بروند و موانع را برای تیم برطرف میکند. این فرد تسهیل کننده جلسات اسکرام مانند Dayli, Planning, Review, Grooming, Retro است. همچنین مسول افزایش بهره وری، سلامت تیم و همکاری با افراد است و تحلیل می‌کند عملکرد تیم چگونه بوده و با شناسایی مشکلات، فرایند‌ها را بهبود می دهد.
  - یک تیم DevOps هم داریم که در پروژه‌های بزرگ باعث کاهش زمان انتشار، افزایش کیفیت، کاهش ریسک و افزایش بهره وری تیم ها میشود. این تیم با کاهش شکاف بین تیم توسعه (Dev) و تیم عملیات (Ops) باعث این دو تیم را باهم یکپارچخ کرده و کندی مربوط به فاصله آن‌ها را از بین می برد.

## Docker

- یک پلتفرم یا سکوی سریع و سبک برای بسته بندی، اجرا و انتقال نرم‌افزار در یک محیط ایزوله به نام Container است. درواقع نرم افزار ما تبدیل به یک بسته به نام Docker Image می شود که می توان از این بسته بی نهایت Docker Container ایجاد کرد که در زمان اجرا می توانند با یک آیپی و پورت در دسترس باشند.
- دارای ویژگی‌ها و مزایای زیر است:

  - حل مشکل «تو سیستم من که کار می‌کنه!»: گاهی ممکن است شرایطی باشد که یک نرم افزار روی سیستم توسعه دهنده کار کند اما روی سیستم همکارش نه. داکر کل محیط اجرا (کد+lib+تنظیمات) را در یک بسته قابل حمل تجمیع می‌کند و این بسته روی هر سیستمی به یک شکل کار خواهد کرد.
  - محیط توسعه یکسان برای همه: هر توسعه دهنده با اجرای یک دستور مثل docker compose up دقیقا همان محیطی را  خواهد داشته که سایر اعضای تیم هم دارند (مثلا با همون نسخه جاوا و دیتابیس).
  - استفاده آسان از سرویس‌های جانبی: همانطور که نرم افزار ما در قالب یک Image بیلد شده و سپس در قالب Container قابل اجرا است، تمامی سرویس های جانبی هم نسخه داکرایز شده دارند. مثلا استفاده از Redis یا Kafka دیگر پیچیده نیست و می توان با یک خط کامند مانند docker run postgres یک دیتابیس Postgres بالا آورد.
  - استقرار آسان: می توان هر اپلیکیشن را به صورت یک docker image درآورد و در هر سرور یا حتی روی کلاد اجرا کرد (در قالب docker container). تنظیمات پیچیده ای هم نخواهد داشت.
  - اجرای تست‌های خودکار: در Docker، می توان از CI/CD  برای اجرای Integration/Unit Test در محیط‌های ایزوله و کنترل شده استفاده کرد.
  - ساخت میکروسرویس‌ها: در محیط‌های میکروسرویسی، هر سرویس با کانتینر خود (شامل زبان، پورت، پلتفرم اجرا و دیتابیس) اجرا می شود.
  - نسخه بندی محیط ها: در داکر می توان نسخه ای خاص از یک نرم افزار خاص را در تنظیمات مشخص کرد (مثلا فقط جاوا 8) تا هر بار که پروژه اجرا می شود، دقیقا با همان نسخه ها اجرا شود.
- در کنار Docker Image که در دیسک ذخیره میشه و از بین نمیره و Docker Container که در رم قرار داره و در صورت توقف دیتای اون از بین میره (مربوط به زمان اجرا است) یک Docker Volume هم داریم که می توان برخی اطلاعات مربوط به یک کانتینر را در آن ذخیره کرد تا در صورت توقف یا حذف آن، بتوان با بالا آمدن دوباره همان کانتینر یا یک مورد جدید، آن دیتا را داشت.

## Cloud

- استفاده از کلاد به معنای استفاده از منابع کامپیوتری (مثل سرور، حافظه، دیتابیس و حتی نرم افزار) از راه دور و از طریق Internet  هست، بدون این که نیازی باشد خودمان آن منابع را بخریم یا مدیریت کنیم. شامل مزایای زیر هست:

  - راه اندازی سریع: در چند دقیقه میتوان سرور، دیتابیس، فضای ذخیره سازی یا سرویس هوش مصنوعی را بالا آورد.
  - پرداخت به اندازه استفاده یا Pay As You Go: فقط به اندازه منابعی که استفاده کردی پول می دهی و نیازی به استفاده از سخت افزار گرون قیمت نیست.
  - مقیاس پذیری: می توان تنظیماتی را قرار داد که برای مثال در صورت افزایش ترافیک وبسایت ما، سرویس دهنده به صورت خودکار منابع را اضافه کند.
  - امنیت بالا و پشتیبانی: فراهم کنندگان سرویس کلاد یا ابری، مکانات امنیتی، پشتیبان گیری خودکار و سیستم های مقابله با حملات را فراهم میکنند.
  - دسترسی از هر جا: با اینترنت، از هرجا و هر دستگاهی می توان به سرور وصل شد.
  - توسعه و تست راحت تر: می توان سریع محیط های مختلف تست و توسعه ایجاد و سپس پاک کرد.
- انواع خدمات کلاد:


| IaaS زیرساخت به عنوان سرویس    | سرور، شبکه، فضای ذخیره سازی | Amazon EC2         |
| --------------------------------------------------- | ---------------------------------------------------- | -------------------- |
| PaaS پلتفرم به عنوان سرویس      | محیط کامل توسعه و استقرار     | Google App Engine  |
| SaaS نرم افزار به عنوان سرویس | App کامل آماده استفاده             | Gmail, Google Docs |

- توسعه در محیط ابری یا Cloud به صورت مقیاس پذیر:
- برنامه باید Stateless طراحی شود. هر Instance از برنامه نباید بهداده‌های لوکال خودش وابسته باشد (مثل حافظه سشن) تمام داده های سشن یا وضعیت ها باید در سرویس هایی مانند ردیس یا دیتابیس مشترک ذخیره شوند. به این شکل می توان چند نمونه از برنامه را همزمان اجرا کرد، بدون این که کار یکدگیر را مختلف کنند.
- برنامه باید مقیاس پذیری افقی یا Horizontal Scaling را پشتیبانی کند. درواقع باید وری طراحی شود که وقتی تعداد کاربران زیاد شد، بتوان تعداد Instanceها را بالا برد (Scale out) نه این که منابع سرور افزایش پیدا کند (Scale up). در این زمینه استفاده از Kubernetes می تواند یک راهکار مناسب باشد.
- کانتینر سازی با Docker باعث می شود اپلیکیشن یا برنامه به راحتی در محیط های مختلف قابل اجرا باشد. همچنین کانتینر های داکر به راحتی قابل استفاده به عنوان پاد در کوبر هستند.
- تنظیمات باید به صورت جداگانه و داینامیک باشد به طوری که در زمان اجرا بتوان آن ها را تغییر داد (Externalized Configs)
- اپ باید از Logging و Monitoring استاندارد پشتیبانی کند.
- اپ باید از Healthcheck  و Readiness Probe پشتیبانی کند.
- برای ارتباطات، استفاده از Message Broker یا Message Queue توصیه می شود.
- Loadbalancing مهم است.
- باید سازوکار CI/CD فراهم باشد.
- دیتابیس باید مقیاس پذیر و مشترک باشد.

## Messaging Architecture

- در این معماری به جای این که اجزای مختلف سامانه (شامل سرویس ها، ماژول‌ها و فرآیندها) به صورت مستقیم (مثلا از طریق REST) همدیگر را فراخوانی کنند، این کار را از طریق پیام انجام می‌دهند. درواقع به جای این که مثلا یک سرویس به نام A سرویس دیگری به نام B را فراخوانی کند، درخواست خود را روی یک صف (Queue یا Topic) قرار می دهد و سرویس B از قبل روی آن صف منتظر دریافت پیام است و آن را خوانده و پاسخ می دهد.
- این معماری مزایایی از جمله موارد زیر دارد:

  - کاهش وابستگی مستقیم: سرویس A نیازی به دانستن سرویس B و نحوه کارکرد آن ندارد. این موضوع انعطاف بیشتر در تغییر یا جابجایی بین سرویس ها ایجاد میکند. بنابراین، اگر سرویسی تغییر کند یا دچار مشکل شود، سیستم به طور کلی دچار مشکل نمی شود.
  - مقیاس پذیری: بدون این که نیاز باشد درخواست کنند تغییری داشته باشد، می توان تعداد بیشتری از Instance های سرویس دهنده را به صف پیام متصل کرد تا درخواست ها را دریافت و پردازش کنند. مثلا اگر سفارش ها زیاد شوند، می توان به راحتی چند مصرف کننده جدید اضافه کرد (درخواست کننده تولید کننده یا Producer دارد و پاسخ دهنده مصرف کننده یا Consumer دارد).
  - تحمل پذیری در برابر خطا یا Fault Tolerance: اگر مصرف کننده از کار بیفتد، پیام ها در صف باقی می مانند تا دوباره در دسترس باشد و پیام ها را مصرف کند و پاسخ بدهد.
  - این معماری غیرهمگامی یا Aynchronous Relations را به ارمغان می آورد. به این صورت که درخواست کنند درخواست خود را روی صف قرار می دهد و منتظر دریافت پاسخ نمیماند. روال مربوطه ادامه پیدا می کند و در صورت دریافت پاسخ، آن را پردازش میکند. این امر در سامانه هایی که در آن ها Latency پایین مهم نیست ولی عملکرد بالا و پاسخگویی مهم است (دسترسپذیری) می تواند مفید باشد.
- SAGA?
- CQRS?
- انواع ابزارهای پیامرسانی:

  - RabbitMQ

    - مبتنی بر پروتکل AMQP (Advance Message Queuing Protocol)
    - صف ها و تبادل پیام (Queues & Exchanges)
    - قابلیت تضمین تحویل پیام (delivery guarantee)
    - قابلیت تأخیر زمانی (delayed messages)
    - کاربرد در سیستم هایی که نیاز به تحویل دقیق و قابل اطمینان پیام دارند. در سیستم های میکروسرویس می توان از قابلیت Task Queue آن استفاده کرد. برای Stream Processing سنگین یا Big Data  مناسب نیست.
  - Apache Kafka

    - طراحی شده برای پردازش حجم بالای داده.
    - پیام ها به شکل log نگهداری می شوند: Distributed commit log
    - قابلیت خواند چندباره پیام ها را دارد
    - با استفاده از Partitioning مقیاس پذیری بالا را فراهم می کند
    - مناسب سیستم های real-time analysis و سیستم های Event-driven  مقیاس پذیر است.
    - با ابزارهایی مثل Kafka Stream می تواند Stream Processing را فراهم کند.
    - از جمله مشکلات آن راه اندازی و نگهداری سخت تر است و در مقابل RabitMQ پیچیدگی بیشتری دارد.
  - ActiveMQ:

    - قدیمی ترین پیام رسان در این لیست است و پیاده سازی کامل Java Message Service یا JMS را دارد.
    - از پروتکل های مختلفی مثل STOMP, AMP, MQTT پشتیبانی می کند.
    - در پروژه های Java EE قدیمی بسیار کاربرد دارد. و همچنین سیستم هایی که با JMS  به شدت Couple هستند.
    - نسبت به دوتای قبلی از نظر مقیاس پذیری و عملکرد ضعیف تر است و در پروژه های جدید کمتر پیشنهاد می شود.
  - جدول زیر به طور خلاصه این موارد را مقایسه می کند.


| ابزار | مناسب برای...                                                                                                                         |
| ------------ | ------------------------------------------------------------------------------------------------------------------------------------------------ |
| RabitMQ    | سیستم های ساده میکروسرویس یا نیاز به پیام گذاری مطمئننیاز به پیام های با تأخیر |
| Kafka      | سیستم Real-time با حجم زیاد دیتا                                                                                             |
| Active MQ  | پروژه های قدیمی با JavaEE و JMS                                                                                                |

## Git

- یک سیستم مدیریت نسخه یا Version Control System
- این ابزار کمک می کند کدهای پروژه را مدیریت، ذخیره، ردیابی و کنترل کنیم.
- به خصوص وقتی چند نفر به صورت همزمان در حال کار روی یک پروژه هستند.
- فرق merge با rebase:
- Git Merge

  - ماهیت: تاریخچه‌ی پروژه رو به شکل شاخه‌ای (branching history) حفظ می‌کنه.
  - عملکرد: وقتی دو شاخه رو با هم ترکیب می‌کنید، یک commit جدید به نام merge commit ساخته می‌شه.
  - ویژگی‌ها:
  - تاریخچه‌ی کامل و واقعی کار رو نگه می‌داره (چه زمانی و کجا شاخه‌ها از هم جدا شدند).
  - تاریخچه کمی شلوغ‌تر می‌شه، ولی هیچ اطلاعاتی حذف یا تغییر نمی‌کنه.
  - مزیت: تاریخچه واقعی کار حفظ می‌شه.
  - عیب: نمودار commitها ممکنه پیچیده و خواندنش سخت بشه.
- Git Rebase

  - ماهیت: تاریخچه رو بازنویسی می‌کنه.
  - عملکرد: تغییرات شاخه‌ی شما رو برمی‌داره و انگار از نو روی شاخه‌ی مقصد (مثلاً main) اعمال می‌کنه.
  - ویژگی‌ها:
  - هیچ merge commit جدیدی تولید نمی‌شه.
  - تاریخچه‌ی پروژه خطی (linear history) و تمیزتر دیده می‌شه.
  - اما commitهای قدیمی دست‌کاری می‌شن (درواقع commit جدیدی ساخته می‌شه که شبیه قبلی‌هاست).
  - مزیت: تاریخچه‌ی خطی و خواناتر.
  - عیب: در پروژه‌های اشتراکی، اگر کسی قبلاً روی commitهای قبلی کار کرده باشه، rebase باعث conflict و مشکلات هماهنگی می‌شه.


| **ویژگی**        | **Merge**                                                            | **Rebase**                                                                     |
| ----------------------- | ---------------------------------------------------------------------- | -------------------------------------------------------------------------------- |
| نوع تاریخچه | شاخه‌ای و واقعی                                         | خطی و بازنویسی‌شده                                             |
| ---                   | ---                                                                  | ---                                                                            |
| Commit جدید       | یک Merge Commit ساخته می‌شه                              | Commitهای موجود بازنویسی می‌شن                            |
| وضوح              | تاریخچه واقعی رو نشون می‌ده، ولی شلوغ | تاریخچه تمیز و ساده                                            |
| خطر                | امن‌تر (چون چیزی تغییر نمی‌ده)               | خطرناک‌تر در تیم (چون commitها بازنویسی می‌شن) |

## Project Build Tools

- Maven یک ابزار مدیریت و ساخت پروژه برای زبان جاوا است. این ابزار مکم میکند کتاب خانه ها و وابستگی های پروژه را از طریق یک فایل به نام pom.xml مدیریت کنیم و نیازی به دانلود دستی آن ها نباشد.
- می توان با دستور mvn compile test package پروژه رو بیلد کرد و تست های آن را نیز اجرا کرد. دستورات دیگری نیز می توان به این دستو اضافه کرد:

  - clean: پوش target رو حذف میکنه (فایل های قدیمی بیلد)
  - compile: فقط کدهای داخل src/main/java را اجرا میکند.
  - package: فایل های اجرایی .jar یا .war تولید میکند.
  - install: فایل پکیج شده را در مخزن های maven برای استفاده در پروژه های دیگر ذخیره می کند.
  - deploy: فایل پروژه را به یک Repository راه دور برای انتشار رسمی ارسال میکند.
  - validate: درستی ساختار پروژه و فایل pom را بررسی میکند.
  - site: گزارشاتی از پروژه تولید میکند.
  - dependency tree: نمایش وابستگی ها و لیست درختی از تمامی کتاب خانه ها و وابستگی ها.
- Gradle یک ابزار مدیریت و ساخت پروژه است که علاوه بر جاوا از زبان‌های دیگر مانند Kotlin و Groovy نیز پشتیبانی می‌کند. این ابزار وابستگی‌ها و تنظیمات پروژه را از طریق فایل‌های build.gradle  (یا build.gradle.kts برای Kotlin DSL) مدیریت می‌کند و نیازی به دانلود دستی کتابخانه‌ها نیست.
- با دستور gradle build  یا ./gradlew build  می‌توان پروژه را بیلد کرد و تست‌ها را نیز اجرا نمود. برخی دستورات پرکاربرد عبارتند از:

  - clean: پوشه‌ی build را حذف می‌کند (فایل‌های بیلد قبلی).
  - compileJava : فقط کدهای موجود در مسیر src/main/java را کامپایل می‌کند.
  - test:  تست‌های موجود در پروژه را اجرا می‌کند.
  - assemble:  فایل اجرایی .jar یا .war را بدون اجرای تست‌ها تولید می‌کند.
  - build:  کل پروژه را بیلد کرده و تست‌ها را نیز اجرا می‌کند.
  - publishToMavenLocal:  پکیج را در مخزن محلی Maven برای استفاده در پروژه‌های دیگر ذخیره می‌کند.
  - publish: پکیج پروژه را به یک Repository راه دور (مثلاً Nexus یا Artifactory) ارسال می‌کند.
  - check:  تمام بررسی‌ها و تست‌های تعریف‌شده را اجرا می‌کند.
  - dependencies:  وابستگی‌های پروژه را به صورت درختی نمایش می‌دهد.



## Cache Memory

- مفهوم Cache: حافظه‌ای موقت که برای ذخیره اطلاعات استفاده می‌شود تا از دسترسی مکرر و بار اضافی روی منابع اصلی جلوگیری شود.
- مزایا:

  - افزایش سرعت دسترسی به داده‌ها
  - کاهش فشار روی دیتابیس یا منابع اصلی
  - بهبود تجربه کاربری
- Cache RAM: نوعی حافظه موقت (RAM) که داده‌ها را برای مدتی نگه می‌دارد تا پردازنده بتواند سریع‌تر به آن‌ها دسترسی پیدا کند.
- ویژگی‌ها:

  - داده‌ها موقتی هستند (Volatile) و با خاموش یا ریست شدن سیستم از بین می‌روند.
  - در صورت نیاز باید داده‌ها به‌روزرسانی شوند.
- Expiration Time در Redis: مدت‌زمانی که داده‌ها در Redis نگهداری می‌شوند و پس از آن به‌طور خودکار حذف می‌شوند.
- کاربردها:

  - تعیین عمر مفید داده‌های موقتی
  - جلوگیری از ذخیره داده‌های قدیمی یا منسوخ
- مثال‌های کاربردی

  - ذخیره Token یا OTP که باید بعد از مدت کوتاهی (مثلاً ۲ دقیقه) منقضی شوند.
  - نگهداری داده‌هایی که کاربر فقط در حین یک فرآیند خرید یا ثبت‌نام نیاز دارد.
  - ذخیره نتایج پردازش‌های سنگین برای مدتی کوتاه به‌منظور افزایش سرعت پاسخگویی.
- نکات مهم

  - همیشه برای داده‌های موقتی، Expiration Time تعیین کنید.
  - برای داده‌های حساس، زمان انقضا کوتاه باشد تا امنیت افزایش پیدا کند.
  - استفاده از Cache به‌معنی حذف کامل دسترسی به منبع اصلی نیست؛ بلکه یک لایه بهینه‌سازی است.

## Reflection

- Reflection قابلیتی در جاوا است که به ما اجازه می‌دهد در زمان اجرا (Runtime) به اطلاعات کلاس‌ها، متدها و فیلدها دسترسی پیدا کنیم. با استفاده از Reflection می‌توانیم:

  - اطلاعات یک کلاس را در زمان اجرا بخوانیم.
  - به فیلدها و متدهای private دسترسی پیدا کنیم.
  - اشیاء را به‌صورت داینامیک ایجاد کنیم.
- مثال کلاس هدف:

<div dir="ltr">

```

public class Person {

    private String name = "Ali";

    public void sayHello() {

        System.out.println("Hello from " + name);

    }

}

```

</div>

- استفاده از Reflection:

  - گرفتن شیء Class از کلاس مورد نظر:

<div dir="ltr">

```

Class<?> cls = Class.forName("Person");

```

</div>

- ساخت نمونه (Instance) از کلاس به صورت داینامیک:

<div dir="ltr">

```

Object obj = cls.getDeclaredConstructor().newInstance();

```

</div>

- دسترسی به فیلد private و تغییر مقدار آن:

<div dir="ltr">

```

Field f = cls.getDeclaredField("name");

f.setAccessible(true); // حذف محدودیت private

f.set(obj, "Reza");    // تغییر مقدار

```

</div>

- دسترسی به متد و اجرای آن:

<div dir="ltr">

```

Method m = cls.getMethod("sayHello");

m.invoke(obj);

```

</div>

- متد setAccessible(true) برای دور زدن محدودیت دسترسی استفاده می‌شود. با Reflection می‌توان متدها یا فیلدهایی را تغییر داد که در حالت عادی به آن‌ها دسترسی نداریم. توجه شود که استفاده بیش‌ازحد از Reflection باعث کاهش کارایی (Performance) برنامه می‌شود.
- کاربردهای Reflection:

  - ایجاد و بارگذاری داینامیک کلاس‌ها (Dynamic Class Loading).
  - فریمورک‌هایی مانند Spring و Hibernate برای مدیریت وابستگی‌ها و کار با کلاس‌ها از Reflection استفاده می‌کنند.
  - تست و دیباگ (Unit Testing) برای دسترسی به بخش‌های private.

## Data Structure in Java


| **ویژگی / ساختار داده**        | **ArrayList**                                     | **LinkedList**                                    | **HashMap**                                        | **HashSet**                                      | **TreeSet**                                                      | **PriorityQueue**                 | **TreeMap**                                                      |
| ----------------------------------------------- | --------------------------------------------------- | --------------------------------------------------- | ---------------------------------------------------- | -------------------------------------------------- | ------------------------------------------------------------------ | ----------------------------------- | ------------------------------------------------------------------ |
| **ساختار داخلی**                   | آرایه داینامیک                       | لیست پیوندی دوطرفه                | جدول هش (Hash Table)                         | بر پایه HashMap                            | درخت جستجوی دودویی متعادل (Red-Black Tree) | هیپ دودویی (Binary Heap) | درخت جستجوی دودویی متعادل (Red-Black Tree) |
| **ترتیب عناصر**                     | بر اساس ترتیب درج                   | بر اساس ترتیب درج                   | بدون ترتیب خاص                         | بدون ترتیب خاص                       | مرتب بر اساس Comparator یا Comparable                | بر اساس اولویت        | مرتب بر اساس کلید                                  |
| **اجازه عناصر تکراری**        | بله                                            | بله                                            | کلید: خیر / مقدار: بله              | خیر                                           | خیر                                                           | بله                            | کلید: خیر / مقدار: بله                            |
| **دسترسی تصادفی با اندیس** | O(1)                                              | O(n)                                              | ندارد                                         | ندارد                                       | ندارد                                                       | ندارد                        | ندارد                                                       |
| **پیچیدگی جستجو**                 | O(n)                                              | O(n)                                              | O(1)                                               | O(1)                                             | O(log n)                                                         | O(n)                              | O(log n)                                                         |
| **پیچیدگی درج (در انتها)**   | O(1) آمورتیزه شده                      | O(1)                                              | O(1)                                               | O(1)                                             | O(log n)                                                         | O(log n)                          | O(log n)                                                         |
| **پیچیدگی درج (در وسط)**       | O(n)                                              | O(n)                                              | O(1)                                               | O(1)                                             | O(log n)                                                         | O(log n)                          | O(log n)                                                         |
| **پیچیدگی حذف (ابتدا)**        | O(n)                                              | O(1)                                              | O(1)                                               | O(1)                                             | O(log n)                                                         | O(log n)                          | O(log n)                                                         |
| **پیچیدگی حذف (وسط)**            | O(n)                                              | O(n)                                              | O(1)                                               | O(1)                                             | O(log n)                                                         | O(log n)                          | O(log n)                                                         |
| **مصرف حافظه**                       | کم                                              | بیشتر به دلیل اشاره‌گرها     | متوسط                                         | متوسط                                       | بیشتر از HashSet                                          | متوسط                        | بیشتر از HashMap                                          |
| **Thread-Safety**                             | خیر (مگر با Collections.synchronizedList) | خیر (مگر با Collections.synchronizedList) | خیر (مگر با Collections.synchronizedMap)   | خیر (مگر با Collections.synchronizedSet) | خیر                                                           | خیر                            | خیر                                                           |
| **قابلیت** **Iteration**                | سریع با Iterator و ListIterator            | کندتر                                        | روی entryها، keyها یا valueها          | فقط روی عناصر                         | مرتب                                                         | بر اساس اولویت        | مرتب بر اساس کلید                                  |
| **موارد استفاده ایده‌آل**  | لیست‌های با دسترسی زیاد       | صف، پشته                                   | نگهداری جفت کلید-مقدار سریع | مجموعه بدون تکرار                 | مجموعه مرتب بدون تکرار                        | صف با اولویت            | نگهداری مرتب جفت کلید-مقدار               |
| **مثال ساخت**                         | new ArrayList<>()                                 | new LinkedList<>()                                | new HashMap<>()                                    | new HashSet<>()                                  | new TreeSet<>()                                                  | new PriorityQueue<>()             | new TreeMap<>()                                                  |

## Search and Sort Algorithms

| **دسته** | **الگوریتم** | **ایده اصلی** | **بهترین حالت** | **متوسط** | **بدترین حالت** | **پیچیدگی فضایی** | **پیش‌شرط‌ها** | **پایدار؟ (فقط مرتب‌سازی)** | **مزایا** | **معایب** | **موارد استفاده ایده‌آل** |
| --- |  --- |  --- |  --- |  --- |  --- |  --- |  --- |  --- |  --- |  --- |  --- |
| **جستجو** | Linear Search | بررسی تک‌تک عناصر | O(1) | O(n) | O(n) | O(1) | بدون پیش‌نیاز | \- | پیاده‌سازی ساده | بسیار کند در داده بزرگ | داده کوچک یا نامرتب |
| **جستجو** | Binary Search | تقسیم لیست مرتب به دو نیم | O(1) | O(log n) | O(log n) | O(1) | داده مرتب | \- | سریع برای داده مرتب | نیاز به داده مرتب | آرایه‌های مرتب |
| **جستجو** | Jump Search | پرش در فواصل ثابت + جستجوی خطی | O(1) | O(√n) | O(√n) | O(1) | داده مرتب | \- | بهتر از خطی، ساده‌تر از دودویی | کندتر از دودویی | داده مرتب متوسط |
| **جستجو** | Interpolation Search | تخمین مکان بر اساس مقدار | O(1) | O(log log n) | O(n) | O(1) | داده مرتب و توزیع یکنواخت | \- | سریع در داده یکنواخت | بد در داده غیر یکنواخت | داده عددی یکنواخت |
| **جستجو** | Exponential Search | دو برابر کردن بازه + دودویی | O(1) | O(log n) | O(log n) | O(1) | داده مرتب | \- | عالی برای داده خیلی بزرگ یا نامعلوم | نیاز به مرتب بودن | داده استریم یا نامحدود |
| **جستجو** | Fibonacci Search | تقسیم بازه با فیبوناچی | O(1) | O(log n) | O(log n) | O(1) | داده مرتب | \- | بهینه‌تر در کش | پیاده‌سازی سخت‌تر | داده مرتب بزرگ |
| **مرتب‌سازی** | Bubble Sort | جابجایی مکرر عناصر مجاور | O(n) | O(n²) | O(n²) | O(1) | \- | بله | ساده، مناسب داده کوچک | بسیار کند | آموزش، داده کوچک |
| **مرتب‌سازی** | Selection Sort | انتخاب کوچکترین و جابجایی | O(n²) | O(n²) | O(n²) | O(1) | \- | خیر | جابجایی کم | سرعت پایین | وقتی هزینه جابجایی مهم است |
| **مرتب‌سازی** | Insertion Sort | درج عنصر در محل مناسب | O(n) | O(n²) | O(n²) | O(1) | \- | بله | سریع در داده کوچک یا مرتب | کند در داده بزرگ | داده کوچک یا تقریباً مرتب |
| **مرتب‌سازی** | Merge Sort | تقسیم و ادغام مرتب | O(n log n) | O(n log n) | O(n log n) | O(n) | \- | بله | پایدار، تضمینی | حافظه اضافی | داده بزرگ پایدار |
| **مرتب‌سازی** | Quick Sort | تقسیم بر اساس pivot | O(n log n) | O(n log n) | O(n²) | O(log n) | \- | خیر | سریع و کم‌حافظه | حساس به pivot بد | داده بزرگ در حافظه |
| **مرتب‌سازی** | Heap Sort | ساخت heap و حذف رأس | O(n log n) | O(n log n) | O(n log n) | O(1) | \- | خیر | حافظه کم، بدترین حالت خوب | کندتر از Quick Sort در عمل | داده بزرگ حساس به worst-case |
| **مرتب‌سازی** | Counting Sort | شمارش مقادیر | O(n+k) | O(n+k) | O(n+k) | O(k) | دامنه محدود | بله | بسیار سریع در دامنه کوچک | حافظه زیاد برای k بزرگ | داده عددی دامنه کوچک |
| **مرتب‌سازی** | Radix Sort | مرتب‌سازی بر اساس رقم‌ها | O(nk) | O(nk) | O(nk) | O(n+k) | داده عددی یا طول ثابت | بله | سریع در داده عددی | محدود به داده خاص | مرتب‌سازی اعداد |
| **مرتب‌سازی** | Bucket Sort | تقسیم به سطل‌ها | O(n+k) | O(n+k) | O(n²) | O(n+k) | توزیع یکنواخت | بله (در صورت استفاده از مرتب‌سازی پایدار) | سریع در داده یکنواخت | بد در داده غیر یکنواخت | داده اعشاری یا توزیع یکنواخت |

## ReST vs. SOAP:

- هر دو روش ها یا پروتکل هایی برای ساخت وب سرویس هستند.
- SOAP مخفف Simple Object Access Protocol هست که پروتکلی رسمی و مبتنی بر XML برای تبادل پیام بین کلاینت و سرور است. در سیستم های Enterprise-level مثل بانک ها یا سازمان های دولتی بهتر است. درواقع وقتی نیاز به امنیت بالا، تراکنش های پیچیده و قابلیت اطمینان وجود دارد. همچنین وقتی که سرویس ها Stateful باشند.
- ReST مخفف Representational State Transfer هست که یک پروتکل سبک و ساده مبتنی بر HTTP است. در طراحی API برای کلاینت هایی مثل موبایل و وب سایت مناسب است. وقتی درستی، سادگی و مصرف پایین مهم باشد. برای سرویس های عمومی، انعطاف پذیر و توسعه پذیر مناسب هست. در این پروتکل متدهای زیر قابل استفاده هستند:

  - Get که برای دریافت اطلاعات از سرور به کار می رود.
  - Post که برای ایجاد یک منبع جدید در سرور به کار می رود.
  - Put که برای به روزرسانی کامل یک منبع استفاده می شود.
  - Patch که برای به روزرسانی جزئی یک منبع استفاده می شود.
  - Delete که برای حذف یک منبع از سرور استفاده می شود.
- جدول مقایسه


| **ویژگی**                           | **REST**                                                                                  | **SOAP**                                                                |
| ------------------------------------------ | ------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------- |
| **پروتکل یا استاندارد** | رویکرد معماری سبک (سبک‌وزن و انعطاف‌پذیر)               | پروتکل استاندارد و رسمی                             |
| **فرمت داده‌ها**              | JSON, XML, Text, HTML و سایر فرمت‌ها                                          | فقط XML                                                              |
| **ساختار درخواست**          | اتکا به HTTP Method و URL (سادگی بالا)                                    | Header و Envelope الزامی (ساختار رسمی و پیچیده) |
| **ساختار پیام**                | سربار پایین، بدنه ساده                                                 | پیچیدگی و سربار بیشتر                                 |
| **HTTP Method**                          | GET, POST, PUT, DELETE, PATCH                                                             | عمدتاً POST                                                       |
| **Statefulness**                         | Stateless (هر درخواست مستقل است)                                         | می‌تواند Stateless یا Stateful باشد                       |
| **امنیت**                           | معمولاً HTTPS و OAuth (امنیت لایه انتقال)                          | WS-Security (امنیت سطح پیام) + گزینه‌های دیگر  |
| **توصیف/کشف سرویس**         | بدون الزام ابزار رسمی؛ مستندسازی معمولی/Swagger/OpenAPI | WSDL برای توصیف رسمی سرویس‌ها                      |

## Different Types of Software Test

- جدول زیر تفاوت بین تست واحد و تست یکپارچگی را نشان می دهد:


| **ویژگی**           | **Unit Test**                                                               | **Integration Test**                                                                                     |
| -------------------------- | ----------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------- |
| **تعریف**           | تست یک ماژول/کلاس به‌صورت جداگانه و مستقل | تست ترکیب چند ماژول یا سرویس با هم و بررسی تعامل آن‌ها        |
| **دامنه تست**    | محدود به منطق و بخش خاص کد                              | گسترده‌تر، شامل لایه‌های مختلف (مثلاً دیتابیس، سرویس، API) |
| **وابستگی‌ها** | وابستگی‌ها با Mock یا Stub جایگزین می‌شوند      | وابستگی‌ها واقعی هستند یا شبیه‌سازی کامل سیستم                   |
| **سرعت اجرا**    | بسیار سریع                                                         | کندتر از Unit Test                                                                                |
| **ابزارها**       | JUnit، Mockito                                                             | Spring Boot Test، Testcontainers، Rest Assured                                                         |
| **هدف**               | اطمینان از درستی عملکرد واحد کد                   | اطمینان از درستی عملکرد اجزای مختلف در کنار هم                     |
| **نقاط ضعف**      | پوشش تعاملات بین ماژول‌ها را ندارد             | مشکل در تشخیص علت دقیق خطاها                                                      |
| **تشخیص خطا**    | سریع و دقیق برای بخش خاص کد                            | ممکن است یافتن منبع خطا دشوار باشد                                           |

- در جاوا برای نوشتن تست واحد یا یونیت تست، می توان از چارچوب Junit استفاده کرد. دارای ویژگی های زیر است:

  - تست خودکار متدها و کلاس ها بدو این که برنامه رو اجرا کنیم
  - تشخیص سریع باگ ها مخصوصا در تغییرات جدید (تست رگرسیون)
  - اجرای مکرر تست ها هر بار بعد از بیلد یا تغییرات
  - انجام تست بدون اجرای دستی یو آی یا دیتابیس با استفاده از ماک و تست ایزوله
  - پشتیبانی از TDD
- کاربردهای Junit شامل موارد زیر است:

  - نوشتن تست برای متدها
  - گروهبندی تست ها
  - تست استثناءها
  - تست مقادیر مورد انتظار
  - اجرای تست ها با انوتیشن هایی مانند AfterEach, BeforeEach, Test و ...

## Monitoring Tools

- ابزارهای پایش یا مانیتورینگ مانند Prometheus نقش حیاتی در نگهداری و پایش سلامت سامانه ها دارند. به ویژه زمانی که وارد دنیای نرم افزارهای توزیع شده سرورها و میکروسرویس ها می شویم.
- هدف اصلی استفاده از ابزارهایی مثل Prometheus مشاهده، پایش و تحلیل سلامت، عملکرد و رفتار سیستم ها به صورت real-time است. اما موارد زیر را می توان به عنوان اهداف و کاربردهای خود Prometheus بیان کرد:

  - پایش منابع سیستم: مثل CPU, RAM, Disk, Network برای سرورها یا کانتینرها
  - هشدار خودکار یا Alerting: اگر وضعیت غیرعادی بود (مثلا استفاده از CPU به بالای 90 درصد رسیده بود) بلافاصله هشدار بدهد.
  - نمایش داده با گراف (Grafana): ساخت داشبورد به صورت تصویری با استفاده از ابزار مجزای گرافانا
  - عیب یابی سریع: در صورت بروز خطا یا افت عملکرد، سریع بفهمی چه مشکلی پیش آمده است.
  - پایش میکروسرویس ها: پایش سلامت و پاسخ دهی سرویس ها در معماری میکروسرویس
  - تحلیل بار و فشار سیستم: بررسی رفتار اپلیکیشن در زمان ترافیک بالا یا Load Monitoring
- اما مهم تریم متریک ها یا شاخص ها برای پایش سیستم شامل موارد زیر است:

  - Latency: زمان پاسخ به یک درخواست در کل سامانه
  - Throughput: تعداد درخواست در واجد زمان. یعنی چند درخواست در ثانیه پاسخ داده شد یا Req/Sec
  - Error rate: درصد درخواست هایی که شکست خورده اند.
  - Availability: درصدر زمانی که سیستم در دسترس است یا همان درصد Uptime
  - CPU Usage: درصد مصرف CPU توسط اپلیکیشن
  - Memory Usage: میزان استفاده از رم به درصد
  - Disk I/O: تعداد یا حجم خواندن و نوشتن روی دیسک (100MB/S write)
  - Network I/O: پهنای باند مصرفی روی شبکه (200KB/S download)
  - Queue Length: تعداد درخواست های منتظر در صف برای مثال در ردیس یا کافکا
- در یک پروژه واقعی باید از ترکیب مانیتورینگ فنی، تجربه کاربر، امنیت و کسب و کار استفاده کرد. جدول زیر سطوح مختلف پایش در یک سامانه نرم افزاری را نشان می دهد:


| سطح پایش              | شاخص‌ها و معیارها                                                                                         |
| ------------------------------ | -------------------------------------------------------------------------------------------------------------------------- |
| System level monitoring      | CPU usage, Memory usage, Disk space, Network I/O, Uptime/Downtime, Process health, Container/VM health                   |
| ---                          | ---                                                                                                                      |
| Application level monitoring | Response time, Error rates, Request throughput, Apdex score, Service dependency health, SLA/SLO tracking                 |
| Database monitoring          | Query performance, Connection count, Locking/Deadlock, Replication lag, Slow queries, Index usage                        |
| Logging & error monitoring   | Exception logs, Authentication/Authorization failures, Latency logs, Centralized log aggregation, Correlation ID tracing |
| Real User Monitoring (RUM)   | Page load time, Bounce rate, Session duration, User journey tracking, Geo-distribution of users                          |
| Security monitoring          | Intrusion attempts, Brute-force detection, Rate limiting alerts, API abuse detection, Vulnerability scanning             |
| Business level metrics       | KPIs, Conversion rate, Average transaction value, Churn rate, Customer satisfaction (CSAT/NPS), Revenue impact           |

## Collection vs. Collections in java.util

- Collection (java.util.Collection)
- تعریف: ریشه‌ی چارچوب کالکشن‌های جاوا. یک «قرارداد» برای مجموعه‌ای از اشیاست. Collection خودش داده نگه نمی‌دارد؛ پیاده‌سازی‌ها (مثل ArrayList، HashSet، ArrayDeque)  داده را نگه می‌دارند.
- ویژگی‌ها: از Iterable ارث می‌برد؛ ممکن است ترتیب داشته یا نداشته باشد؛ تکراری‌ها بسته به نوع مجاز یا غیرمجازند (Set تکراری ندارد)؛ پذیرش null به پیاده‌سازی بستگی دارد؛ برخی عملیات «اختیاری» هستند و ممکن است UnsupportedOperationException  بدهند (مثلاً در کالکشن‌های غیرقابل‌تغییر).
- متدهای پرس‌وجو (Query):

  - size()  تعداد اعضا.
  - isEmpty()  تهی بودن مجموعه.
  - contains(Object o)  وجود عضو بر اساس equals.
  - iterator()  بازگرداندن یک تکرارگر «fail-fast» در اکثر پیاده‌سازی‌ها.
  - toArray()  برگرداندن آرایه‌ی Object\[\].
  - <T> T\[\] toArray(T\[\] a)  کپی تایپ‌شده در آرایه‌ی ورودی یا آرایه‌ی جدید.
  - <T> T\[\] toArray(IntFunction<T\[\]> generator)  نسخه‌ی جنریک با سازنده‌ی آرایه (از جاوا 11).
- متدهای تغییر (Modification):

  - boolean add(E e) افزودن عضو (اختیاری).
  - boolean remove(Object o) حذف اولین وقوع بر اساس equals.
  - boolean addAll(Collection<? extends E> c) افزودن جمعی. boolean removeAll(Collection<?> c) حذف همه‌ی اعضایی که در c هستند.
  - boolean retainAll(Collection<?> c) نگه‌داشتن فقط اعضایی که در c هستند (تقاطع).
  - void clear() خالی کردن مجموعه.
- متدهای جمعی/مقایسه:

  - boolean containsAll(Collection<?> c) زیرمجموعه بودن.
  - boolean equals(Object o) برابری ساختاری طبق قرارداد عمومی کالکشن‌ها.
  - int hashCode() سازگار با equals.
- متدهای پیش‌فرض (از جاوا 8 به بعد):

  - default boolean removeIf(Predicate<? super E> filter) حذف شرطی.
  - default Spliterator<E> spliterator() برای پیمایش موازی.
  - default Stream<E> stream() ایجاد Stream ترتیبی.
  - default Stream<E> parallelStream() ایجاد Stream موازی.
  - default void forEach(Consumer<? super E> action) از Iterable به ارث می‌رسد.
- نکات مهم قراردادی:

  - تغییر هم‌زمان هنگام پیمایش معمولاً ConcurrentModificationException می‌دهد (fail-fast).
  - نخ‌-ایمن نیست مگر پیاده‌سازی یا پوشش‌دهنده‌ی جداگانه استفاده شود.
  - Map عضو سلسله‌مراتب Collection نیست (کنار آن قرار دارد).
- زیررسته‌ها:

  - List ترتیب‌دار و دارای index، تکراری مجاز.
  - Set  بدون عضو تکراری (برابری براساس equals/hashCode).
  - Queue / Deque  صف‌ها (FIFO/LIFO)، اولویت‌دار یا دوتایی.
- Collections (java.util.Collections)
- تعریف: کلاس نهایی (final) با سازنده‌ی خصوصی؛ فقط متدهای کمکی «ایستا» برای کار با کالکشن‌ها. آبجکت داده‌ای نگه نمی‌دارد.
- الگوریتم‌ها و مرتب‌سازی/جست‌وجو:

  - static <T extends Comparable<? super T>> void sort(List<T> list) مرتب‌سازی طبیعی. static <T> void sort(List<T> list, Comparator<? super T> c) مرتب‌سازی با مقایسه‌گر. static int binarySearch(List<? extends Comparable<? super T>> list, T key) جست‌وجوی دودویی روی لیستِ از پیش مرتب‌شده. static <T> int binarySearch(List<? extends T> list, T key, Comparator<? super T> c) نسخه‌ی با Comparator. static <T> T min(Collection<? extends T> coll, Comparator<? super T> c) کمینه با Comparator. static <T extends Object & Comparable<? super T>> T min(Collection<? extends T> coll) کمینه طبیعی؛ \`max(...)\` هم‌ارزش‌ها. static void reverse(List<?> list) معکوس کردن ترتیب.
  - static void shuffle(List<?> list) درهم‌زدن تصادفی؛ نسخه با Random هم دارد. static void rotate(List<?> list, int distance) چرخش عناصر.
  - static <T> void swap(List<?> list, int i, int j) جابجایی دو اندیس. static <T> boolean replaceAll(List<T> list, T oldVal, T newVal) جایگزینی همه‌ی وقوع‌ها. static void fill(List<? super T> list, T obj) پرکردن با مقدار ثابت. static <T> void copy(List<? super T> dest, List<? extends T> src) کپی هم‌اندازه (dest باید به‌قدر کافی ظرفیت داشته باشد). static int indexOfSubList(List<?> source, List<?> target) اولین محل زیرفهرست. static int lastIndexOfSubList(List<?> source, List<?> target) آخرین محل زیرفهرست.
  - static <T> Comparator<T> reverseOrder() ساخت Comparator معکوس؛ نسخه با Comparator ورودی نیز دارد.
- ابزارهای آماری/مجموعه‌ای:

  - static int frequency(Collection<?> c, Object o) تعداد وقوع یک شیء. static boolean disjoint(Collection<?> c1, Collection<?> c2) نداشتن اشتراک.
- سازنده‌های کم‌هزینه و ثابت:

  - static <T> List<T> nCopies(int n, T o) لیست فقط‌خواندنی با n کپی یک مقدار.
  - static <T> Set<T> singleton(T o) مجموعه‌ی تک‌عضوی؛ singletonList و singletonMap هم‌ارزش‌ها.
  - static <T> List<T> emptyList() ، static <T> Set<T> emptySet() ، static <K,V> Map<K,V> emptyMap() آبجکت‌های تهی مشترک.
  - static <T> Iterator<T> emptyIterator() ، emptyListIterator() ، static <T> Enumeration<T> emptyEnumeration() نسخه‌های تهی.
  - static <T> List<T> list(Enumeration<T> e) تبدیل Enumeration به List.
  - static <T> Enumeration<T> enumeration(Collection<T> c) تبدیل برعکس.
- پوشش‌دهنده‌های نمایشی (wrappers):

  - static <T> Collection<T> unmodifiableCollection(Collection<? extends T> c)  نماهای فقط‌خواندنی؛ نسخه‌های unmodifiableList/Set/SortedSet/NavigableSet/Map/SortedMap/NavigableMap نیز موجود است.
  - static <T> Collection<T> synchronizedCollection(Collection<T> c)  نماهای نخ‌-ایمن با قفل داخلی؛ نسخه‌های synchronizedList/Set/SortedSet/NavigableSet/Map/SortedMap/NavigableMap نیز موجود است.
  - static <T> Collection<T> checkedCollection(Collection<T> c, Class<T> type)  نماهای دارای «بررسی نوع در زمان اجرا»؛ نسخه‌های checkedList/Set/SortedSet/NavigableSet/Map/SortedMap/NavigableMap/Queue  نیز موجود است.
  - static <E> Set<E> newSetFromMap(Map<E,Boolean> map)  ساخت Set پشت‌-بندی‌شده با یک Map دلخواه.
  - static <T> boolean addAll(Collection<? super T> c, T... elements)  افزودن چندتایی با varargs.
  - static <T> Queue<T> asLifoQueue(Deque<T> deque) نمای LIFO بر روی یک Deque.
- نکات استفاده:

  - بسیاری از متدها «نما» (View) می‌سازند و داده را کپی نمی‌کنند؛ تغییر کالکشن زیرین روی نما اثر می‌گذارد.
  - رَپِرهای synchronized هنگام تکرار نیاز به قفل‌کردن دستی روی آبجکت برگردانده‌شده دارند تا ایمن باشند.
  - متدهای جست‌وجوی دودویی فقط در صورتی معتبرند که لیست مطابق همان Comparator مرتب شده باشد.
- جدول مقایسه ای


| **موضوع**                           | **Collection**                                                                                                                                                                          | **Collections**                                                                                                                                                                                                                                                                                                                        |
| ------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| نوع                                   | اینترفیس                                                                                                                                                                        | کلاس نهایی (final) با سازنده‌ی خصوصی                                                                                                                                                                                                                                                                           |
| ---                                      | ---                                                                                                                                                                                     | ---                                                                                                                                                                                                                                                                                                                                    |
| هدف                                   | قرارداد مشترک برای همه‌ی کالکشن‌ها (چه رفتاری باید ارائه کنند)                                                                       | متدهای کمکی ایستا برای ساخت/تغییر/مرتب‌سازی/ایمن‌سازی کالکشن‌ها                                                                                                                                                                                                                 |
| جایگاه در پکیج               | java.util.Collection                                                                                                                                                                    | java.util.Collections                                                                                                                                                                                                                                                                                                                  |
| ایجاد شیء                        | به‌طور مستقیم قابل ایجاد نیست؛ باید از پیاده‌سازی‌ها استفاده شود (ArrayList، HashSet، ...)                                     | خود کلاس ایجاد نمی‌شود؛ متدهای static روی کالکشن‌های موجود کار می‌کنند یا نما می‌سازند                                                                                                                                                                              |
| نمونه متدهای اصلی         | size, isEmpty, contains, iterator, toArray, add, remove, addAll, removeAll, retainAll, clear, containsAll + پیش‌فرض‌ها removeIf, stream, parallelStream, spliterator, forEach | الگوریتم‌ها sort, binarySearch, reverse, shuffle, rotate, swap, fill, copy, replaceAll, min, max, frequency, disjoint, indexOfSubList؛ سازنده‌ها emptyXxx, singletonXxx, nCopies؛ نماها unmodifiableXxx, synchronizedXxx, checkedXxx؛ ابزارها enumeration, list, addAll, newSetFromMap, asLifoQueue |
| رابطه با Thread-Safety            | قراردادی ندارد؛ بسته به پیاده‌سازی                                                                                                                        | با synchronizedXxx نماهای نخ‌-ایمن می‌سازد                                                                                                                                                                                                                                                                       |
| تغییرپذیری                     | بستگی به پیاده‌سازی دارد؛ برخی فقط‌خواندنی هستند                                                                                              | می‌تواند نماهای فقط‌خواندنی (unmodifiableXxx) یا بررسی نوع در زمان اجرا (checkedXxx) ایجاد کند                                                                                                                                                                                    |
| موارد استفاده‌ی تیپیک | تعریف APIهایی که با «هر نوع کالکشن» کار کنند؛ حلقه و پیمایش؛ عملیات CRUD بر مجموعه                                          | مرتب‌سازی و جست‌وجو؛ ساخت نماهای امن/غیرقابل‌تغییر؛ ساخت کالکشن‌های تهی/تک‌عضوی؛ تبدیل Enumeration/Deque                                                                                                                                                    |

## Instance Variable vs. Static Variable

- Instance Variable
- تعریف: متغیری که در سطح کلاس تعریف می‌شود ولی به هر شیء (object) تعلق دارد.
- ویژگی‌ها:

  - نام دیگر: Non-static variable.
  - به هر نمونه از کلاس یک کپی جداگانه می دهد.
  - در heap همراه با شیء ساخته می‌شود و با نابودی شیء از بین می‌رود.
  - برای دسترسی باید شیء ساخته شود (obj.var).
  - مقدار پیش‌فرض دارد (برای int=0، boolean=false  و ...)
  - می‌تواند modifiers داشته باشد (private, public, protected, default).
  - می‌تواند final باشد (در این صورت باید در constructor مقداردهی شود).
  - چرخه‌ی حیاتش = عمر شیء.
  - مثال

<div dir="ltr">

```

class Car {

    String color;   // instance variable

    int speed;      // instance variable

}

Car c1 = new Car();

Car c2 = new Car();

c1.color = "Red";

c2.color = "Blue";  // هر شیء مقدار جداگانه دارد

```

</div>

- Static Variable
- تعریف: متغیری که با کل کلاس مرتبط است و به همه‌ی اشیاء کلاس به صورت مشترک تعلق دارد.
- ویژگی‌ها:

  - فقط یک کپی در کل JVM دارد، نه به ازای هر شیء.
  - در memory area مخصوص متغیرهای static (در JVM: Method/Class-Area) ذخیره می‌شود.
  - به محض لود شدن کلاس ساخته می‌شود و تا پایان اجرای برنامه وجود دارد.
  - می‌توان بدون ساخت شیء از طریق ClassName.var به آن دسترسی داشت.
  - توسط همه‌ی اشیاء مشترک است؛ تغییر توسط یک شیء، برای بقیه هم قابل مشاهده است.
  - دارای مقدار پیش‌فرض مشابه instance variable است.
  - اغلب برای مقادیر مشترک بین همه‌ی اشیاء (مثل شمارنده‌ها، پیکربندی‌ها) استفاده می‌شود.
- مثال

<div dir="ltr">

```

class Car {

    static int wheels = 4;   // static variable

    String color;            // instance variable

}

Car c1 = new Car();

Car c2 = new Car();

c1.color = "Red";

c2.color = "Blue";

System.out.println(Car.wheels); // همه‌ی ماشین‌ها 4 چرخ دارند

```

</div>

- جدول مقایسه ای


| **ویژگی**             | **Instance Variable**                                                                 | **Static Variable**                                                                           |
| ---------------------------- | --------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------- |
| وابستگی             | به هر شیء کلاس تعلق دارد                                           | به خود کلاس تعلق دارد                                                        |
| تعداد کپی          | به ازای هر object یک کپی                                                 | فقط یک کپی مشترک بین همه‌ی objectها                                    |
| محل ذخیره          | Heap همراه با object                                                           | Method Area / Class Area در JVM                                                             |
| ایجاد و نابودی | با ساخت/نابودی شیء                                                     | با بارگذاری/خروج کلاس از JVM                                              |
| دسترسی               | از طریق object (obj.var)                                                        | از طریق کلاس یا object (ClassName.var)                                            |
| مقداردهی           | می‌تواند در constructor یا مستقیم در تعریف انجام شود | می‌تواند در static block یا مستقیم در تعریف انجام شود        |
| اشتراک داده      | داده‌ی خصوصی برای هر شیء                                          | داده‌ی مشترک برای همه‌ی اشیاء                                        |
| نمونه کاربرد    | ویژگی‌های خاص هر نمونه (رنگ ماشین، نام کاربر)     | ویژگی‌های مشترک (تعداد چرخ ماشین، شمارنده کل اشیاء) |

## == vs. equals in Java

- عملگر ==
- تعریف: عملگر مقایسه‌ی برابری در جاوا.
- ویژگی‌ها:

  - برای نوع‌های اولیه (primitive types)، مقدارها رو مقایسه می‌کنه (مثلاً 5 == 5 → true).
  - برای اشیاء (objects)، مراجع (references) رو مقایسه می‌کنه، یعنی بررسی می‌کنه آیا هر دو به یک محل حافظه اشاره می‌کنن یا نه.
  - تغییرپذیر نیست و قابل override کردن نیست (چون یک عملگر جاواست).
  - در صورت استفاده روی آبجکت‌ها، حتی اگر مقادیر درونی یکسان باشن، ممکنه false بده (مگر این که هر دو به یک شیء واقعی اشاره کنن).
- مثال

<div dir="ltr">

```

String a = new String("java");

String b = new String("java");

System.out.println(a == b); // false -> چون دو آبجکت متفاوت در حافظه

int x = 10, y = 10;

System.out.println(x == y); // true -> چون primitive ها برابرن

```

</div>

- متد equals()
- تعریف: متدی از کلاس Object که برای مقایسه‌ی "مفهومی" اشیاء طراحی شده.
- ویژگی‌ها:

  - در کلاس Object به صورت پیش‌فرض مثل == عمل می‌کنه (مقایسه‌ی مرجع).
  - اما اکثر کلاس‌ها (مثل String, Integer, Date, List) این متد رو override می‌کنن تا مقایسه‌ی مقدار درونی (content equality) انجام بشه.
  - می‌تونه توسط برنامه‌نویس برای کلاس‌های سفارشی override بشه.
  - باید قرارداد equals رعایت بشه (reflexive, symmetric, transitive, consistent, null-safe).
- مثال

<div dir="ltr">

```

String a = new String("java");

String b = new String("java");

System.out.println(a.equals(b)); // true -> چون محتوا یکسان است

class Person {

    String name;

    Person(String n) { this.name = n; }

    @Override

    public boolean equals(Object o) {

        if (this == o) return true;

        if (!(o instanceof Person)) return false;

        Person p = (Person) o;

        return name.equals(p.name);

    }

}

Person p1 = new Person("Ali");

Person p2 = new Person("Ali");

System.out.println(p1.equals(p2)); // true

```

</div>

- جدول مقایسه == و  equals


| **ویژگی**                | **\==**                                                                                            | **equals()**                                                                                                                                          |
| ------------------------------- | ---------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------- |
| نوع                        | عملگر                                                                                         | متد (از کلاس Object)                                                                                                                         |
| قابل Override             | خیر                                                                                             | بله                                                                                                                                                |
| مقایسه روی primitive | مقدارها رو مقایسه می‌کنه                                                      | قابل استفاده نیست (فقط روی objects صدا زده میشه)                                                                       |
| مقایسه روی object    | مراجع (آدرس حافظه) رو مقایسه می‌کنه                                    | به صورت پیش‌فرض مثل\== عمل می‌کنه، ولی اغلب override میشه تا مقایسه‌ی محتوایی انجام بده |
| استفاده‌ی معمول | برای primitiveها یا بررسی اینکه دو مرجع یک object رو نشون میدن | برای بررسی برابری محتوایی اشیاء (Strings, Wrappers, Collections)                                                           |
| مثال                      | a == b                                                                                             | a.equals(b)                                                                                                                                           |

## hashCode besides equals

- متد hashCode()
- تعریف: متدی از کلاس Object که یک عدد صحیح (int) بازمی‌گرداند و نشان‌دهنده‌ی مقدار هش (hash value) شیء است.
- ویژگی‌ها:

  - هر شیء در جاوا یک hashCode() دارد.
  - به طور پیش‌فرض در کلاس Object، hashCode() معمولاً از آدرس حافظه‌ی شیء مشتق می‌شود (implementation-dependent).
  - معمولاً توسط کلاس‌ها override می‌شود (مثل String, Integer, HashMap entryها).
  - برای استفاده در ساختارهای هش (HashMap, HashSet, Hashtable) حیاتی است.
  - اگر دو شیء با equals() برابر باشند، باید hashCode() یکسان داشته باشند (قرارداد جاوا).
  - برعکس الزام ندارد: دو شیء می‌توانند hashCode() برابر داشته باشند ولی برابر از نظر equals() نباشند (collision).
  - مقدار بازگشتی hashCode() می‌تواند منفی یا مثبت باشد.
- نمونه قرارداد:

  - اگر a.equals(b) == true → a.hashCode() == b.hashCode() باید برقرار باشد.
  - اگر a.equals(b) == false → a.hashCode() == b.hashCode() ممکن است برقرار باشد یا نباشد.
- مثال:

<div dir="ltr">

```

String s1 = "java";

String s2 = "java";

System.out.println(s1.equals(s2));    // true

System.out.println(s1.hashCode());    // 3254818

System.out.println(s2.hashCode());    // 3254818 (یکسان)

String s3 = "JVM";

String s4 = "Hash";

System.out.println(s3.hashCode());    // 74719

System.out.println(s4.hashCode());    // 2242438 (متفاوت)

```

</div>

- جدول مقایسه:


| **ویژگی**        | **equals()**                                                                | **hashCode()**                                                                                                |
| ----------------------- | ----------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------- |
| نوع                | متد در کلاس Object                                                 | متد در کلاس Object                                                                                   |
| ---                   | ---                                                                         | ---                                                                                                           |
| خروجی            | boolean (true/false)                                                        | int (کد هش)                                                                                               |
| هدف                | مقایسه‌ی برابری مفهومی یا مرجع شیء             | تولید یک کد هش برای استفاده در ساختارهای داده‌ای مبتنی بر هش |
| قرارداد        | اگر دو شیء برابر باشند باید true برگرداند     | اگر دو شیء برابر باشند باید hashCode یکسان داشته باشند                   |
| Override معمول   | برای مقایسه‌ی محتوایی در کلاس‌های سفارشی | همراه با equals() باید override شود تا سازگاری حفظ شود                           |
| کاربرد اصلی | بررسی برابری منطقی اشیاء                               | مکان‌یابی سریع شیء در HashMap / HashSet                                                     |
| رابطه            | مبنای منطقی برای برابری                                 | مبنای کارایی برای برابری (bucket selection)                                              |
| مثال              | "java".equals("java") → true                                               | "java".hashCode() → 3254818                                                                                  |

- یکی از رایج‌ترین اشتباه‌ها در جاوا اینه که equals() رو override می‌کنیم ولی hashCode() رو فراموش می‌کنیم.
- نتیجه؟ اشیاء در ساختارهایی مثل HashSet و HashMap درست کار نمی‌کنن. در مثال زیر،

  - equals() می‌گه p1 و p2 برابرن.
  - اما چون hashCode() override نشده، JVM از پیاده‌سازی پیش‌فرض استفاده می‌کنه (بر اساس آدرس حافظه).
  - بنابراین HashSet فکر می‌کنه این دو شیء در bucketهای متفاوت هستن و هر دو رو نگه می‌داره.

<div dir="ltr">

```

import java.util.\*;

class Person {

    String name;

    Person(String name) {

        this.name = name;

    }

    @Override

    public boolean equals(Object o) {

        if (this == o) return true;

        if (!(o instanceof Person)) return false;

        Person p = (Person) o;

        return Objects.equals(name, p.name);

    }

    // ❌ hashCode() override نشده

}

public class Test {

    public static void main(String\[\] args) {

        Person p1 = new Person("Ali");

        Person p2 = new Person("Ali");

        System.out.println(p1.equals(p2)); // true

        Set<Person> set = new HashSet<>();

        set.add(p1);

        set.add(p2);

        System.out.println(set.size()); // ❌ خروجی 2 به جای 1

    }

}

```

</div>

- مثال درست:

  - حالا hashCode() و equals() هر دو بر اساس فیلد name تعریف شدن.
  - پس p1 و p2 هم equals برابرن و هم hashCode برابر.
  - HashSet درست عمل می‌کنه و فقط یکی رو نگه می‌داره.

<div dir="ltr">

```

import java.util.\*;

class Person {

    String name;

    Person(String name) {

        this.name = name;

    }

    @Override

    public boolean equals(Object o) {

        if (this == o) return true;

        if (!(o instanceof Person)) return false;

        Person p = (Person) o;

        return Objects.equals(name, p.name);

    }

    @Override

    public int hashCode() {

        return Objects.hash(name);

    }

}

public class Test {

    public static void main(String\[\] args) {

        Person p1 = new Person("Ali");

        Person p2 = new Person("Ali");

        System.out.println(p1.equals(p2)); // true

        Set<Person> set = new HashSet<>();

        set.add(p1);

        set.add(p2);

        System.out.println(set.size()); // ✅ خروجی 1

    }

}

```

</div>

## Thread and Synchronized

- Thread در جاوا

  - Thread یک واحد اجرای مستقل در یک برنامه است.
  - هر برنامه جاوا به طور پیش‌فرض حداقل یک Thread دارد: main thread.
  - می‌توانیم چندین Thread بسازیم تا کارها به صورت همزمان (concurrent) یا موازی (parallel) انجام شوند.
- Multithreading در جاوا

  - یعنی اجرای همزمان چند Thread در یک برنامه.
  - باعث افزایش کارایی در پردازنده‌های چند هسته‌ای و بهبود تجربه کاربر می‌شود.
  - جاوا از طریق Thread class و Runnable interface از Multithreading پشتیبانی می‌کند.
- روش‌های ایجاد Thread

  - ارث‌بری از کلاس Thread

<div dir="ltr">

```

class MyThread extends Thread {

    public void run() {

        System.out.println("Thread در حال اجراست: " + Thread.currentThread().getName());

    }

}

public class Test {

    public static void main(String\[\] args) {

        MyThread t1 = new MyThread();

        t1.start(); // اجرای Thread جدید

    }

}

```

</div>

- پیاده سازی اینترفیس Runnable

<div dir="ltr">

```

class MyRunnable implements Runnable {

    public void run() {

        System.out.println("Thread در حال اجراست: " + Thread.currentThread().getName());

    }

}

public class Test {

    public static void main(String\[\] args) {

        Thread t1 = new Thread(new MyRunnable());

        t1.start();

    }

}

```

</div>

- وضعیت های مختلف Thread

  - New: ساخته شده ولی هنوز start نشده.
  - Runnable: آماده اجراست ولی CPU هنوز بهش زمان نداده.
  - Running: در حال اجراست.
  - Waiting / Timed Waiting: منتظر یک شرط یا زمان مشخص است.
  - Terminated (Dead): اجرای Thread تمام شده.
- وقتی چند Thread به طور همزمان روی منابع مشترک (shared resource) کار کنند، احتمال ناسازگاری داده‌ها وجود دارد. به این مشکل Race Condition می گویند. برای جلوگیری از این مشکل از synchronization استفاده می‌کنیم.
- عبارت synchronized در جاوا برای حل این مشکل به کار می رود. synchronized یک کلمه کلیدی است که دسترسی چندین Thread به منابع مشترک را کنترل می‌کند.
- انواع کاربرد:

  - Synchronized Method فقط یک Thread در هر لحظه می‌تواند وارد متد شود.

<div dir="ltr">

```

class Counter {

    private int count = 0;

    public synchronized void increment() {

        count++;

    }

    public int getCount() {

        return count;

    }

}

public class Test {

    public static void main(String\[\] args) throws InterruptedException {

        Counter counter = new Counter();

        Thread t1 = new Thread(() -> { for (int i=0; i<1000; i++) counter.increment(); });

        Thread t2 = new Thread(() -> { for (int i=0; i<1000; i++) counter.increment(); });

        t1.start(); t2.start();

        t1.join(); t2.join();  // ترد اصلی صبر میکنه تا هردو ترد تموم بشن

        System.out.println("Count = " + counter.getCount()); // همیشه 2000

    }

}

```

</div>

- Synchronized Block به جای قفل کردن کل متد، فقط یک بخش خاص را قفل می‌کنیم (کارایی بالاتر).

<div dir="ltr">

```

class Counter {

    private int count = 0;

    public void increment() {

        synchronized (this) {

            count++;

        }

    }

}

```

</div>

- Static Synchronized Method قفل روی کلاس گرفته می‌شود نه روی شیء.

<div dir="ltr">

```

class Logger {

    private static int logCount = 0;

    public static synchronized void log(String msg) {

        logCount++;

        System.out.println(msg);

    }

}

```

</div>

- Synchronized Block روی یک شیء خاص. می‌توانیم به جای this روی یک شیء دیگر قفل کنیم.

<div dir="ltr">

```

class Example {

    private final Object lock = new Object();

    public void doTask() {

        synchronized (lock) {

            // کد بحرانی

            System.out.println("Task is running safely!");

        }

    }

}

```

</div>

- جمع‌بندی در قالب جدول:


| **موضوع**             | **توضیح**                                                                                     | **مثال**                                         |
| ---------------------------- | ---------------------------------------------------------------------------------------------------- | ------------------------------------------------------ |
| Thread                     | واحد اجرای مستقل در برنامه                                                   | کلاس Thread یا Runnable                        |
| Multithreading             | اجرای همزمان چند Thread                                                              | اجرای همزمان I/O و محاسبات        |
| Race Condition             | دسترسی همزمان به منابع مشترک که باعث ناسازگاری می‌شود | افزایش شمارنده بدون synchronization |
| synchronized method        | قفل روی کل متد                                                                          | public synchronized void increment()                 |
| synchronized block         | قفل روی بخشی از کد                                                                   | synchronized(this) { ... }                           |
| static synchronized method | قفل روی کل کلاس                                                                        | public static synchronized void log()                |
| synchronized on object     | قفل روی یک شیء مشخص                                                                 | synchronized(lock) { ... }                           |

- Reentrant lock vs. synchronized
- ReentrantLock یک کلاس در پکیج java.util.concurrent.locks است. کار اصلیش مثل synchronized است: جلوگیری از دسترسی همزمان چند Thread به بخش بحرانی (critical section). ولی امکانات بیشتری نسبت به synchronized می‌دهد.

  - انعطاف‌پذیرتر از synchronized: می‌توان قفل را به صورت دستی بگیریم (lock()) و آزاد کنیم (unlock()). در synchronized این کار اتوماتیک انجام می‌شود.
  - قابلیت Reentrancy (قفل تو در تو): یعنی اگر یک Thread قفل را گرفته باشد، می‌تواند دوباره همان قفل را بدون بلاک شدن بگیرد.
  - TryLock: در synchronized اگر قفل گرفته شود، Threadهای دیگر باید منتظر بمانند. در ReentrantLock می‌توان با tryLock() تلاش کرد قفل را بگیریم، اگر آزاد بود می‌گیریم، اگر نه بلافاصله برمی‌گردیم (بدون انتظار).
  - Timeout در گرفتن قفل: با tryLock(long time, TimeUnit unit) می‌توانیم تعیین کنیم فقط تا یک زمان خاص منتظر گرفتن قفل بمانیم.
  - Fair Lock (قفل عادلانه): می‌توان مشخص کرد که ترتیب گرفتن قفل بر اساس صف FIFO باشد. در synchronized چنین امکانی نداریم.
- مثال استفاده از Reentrant lock:

<div dir="ltr">

```

import java.util.concurrent.locks.ReentrantLock;

class Counter {

    private int count = 0;

    private final ReentrantLock lock = new ReentrantLock();

    public void increment() {

        lock.lock(); // گرفتن قفل

        try {

            count++;

        } finally {

            lock.unlock(); // آزاد کردن قفل (حتما در finally!)

        }

    }

    public int getCount() {

        return count;

    }

}

public class Test {

    public static void main(String\[\] args) throws InterruptedException {

        Counter counter = new Counter();

        Thread t1 = new Thread(() -> { for (int i=0; i<1000; i++) counter.increment(); });

        Thread t2 = new Thread(() -> { for (int i=0; i<1000; i++) counter.increment(); });

        t1.start(); t2.start();

        t1.join(); t2.join();

        System.out.println("Count = " + counter.getCount()); // همیشه 2000

    }

}

```

</div>

- مثال استفاده از tryLock:

<div dir="ltr">

```

import java.util.concurrent.locks.ReentrantLock;

class Example {

    private final ReentrantLock lock = new ReentrantLock();

    public void doTask() {

        if (lock.tryLock()) { // تلاش برای گرفتن قفل

            try {

                System.out.println(Thread.currentThread().getName() + " وارد بخش بحرانی شد");

            } finally {

                lock.unlock();

            }

        } else {

            System.out.println(Thread.currentThread().getName() + " نتونست قفل بگیره");

        }

    }

}

public class Test {

    public static void main(String\[\] args) {

        Example ex = new Example();

        Thread t1 = new Thread(ex::doTask, "Thread-1");

        Thread t2 = new Thread(ex::doTask, "Thread-2");

        t1.start();

        t2.start();

    }

}

```

</div>

- مثال قفل عادلانه: در این حالت Threadها به ترتیب ورود قفل را می‌گیرند. در حالت پیش‌فرض (false)، Threadها ممکن است بر اساس شانس یا CPU scheduling زودتر قفل بگیرند.

<div dir="ltr">

```

ReentrantLock fairLock = new ReentrantLock(true); // true = fair lock

```

</div>

- به طور کلی:

  - اگر کد ساده و کوتاه داری → synchronized کافی است.
  - اگر کنترل بیشتری لازم داری (timeout، fair lock، tryLock) → ReentrantLock انتخاب بهتری است.
- جدول مقایسه:


| **ویژگی**                            | **synchronized**                                                   | **ReentrantLock**                              |
| ------------------------------------------- | -------------------------------------------------------------------- | ------------------------------------------------ |
| مدیریت قفل                       | خودکار (ورود = گرفتن، خروج = آزادسازی) | دستی (lock() و unlock())                  |
| بلوکه شدن                         | همیشه منتظر می‌ماند                               | امکان tryLock() و timeout                |
| عادلانه بودن (Fairness)        | ندارد                                                         | دارد (با true در سازنده)         |
| چند بار ورود (Reentrancy)       | دارد                                                           | دارد                                       |
| کارایی در بار سنگین       | ساده ولی کندتر                                         | سریع‌تر و انعطاف‌پذیرتر   |
| قابلیت بررسی وضعیت قفل | ندارد                                                         | دارد (isLocked(), isHeldByCurrentThread()) |

## Scalable System Design Principals

- اصول طراحی اولیه

  - رعایت اصل SRP (Single Responsibility Principle)
  - استفاده از Dependency Injection (تزریق وابستگی‌ها)
  - طراحی مبتنی بر Interface و Strategy Pattern
  - استفاده از Factory / Template Method / Observer / Event
  - تعریف API Contract روشن و مشخص
  - استفاده از DTOs برای انتقال داده بین لایه‌ها
  - استفاده از Configuration Externalization (جدا کردن تنظیمات از کد)
  - داشتن Unit Test و Integration Test منظم
  - مدیریت DTO Mapping (مثلاً با MapStruct)
- معماری و طراحی سطح بالا

  - سیستم باید Stateless Design باشد (بدون نگه داشتن Session سمت اپلیکیشن).
  - اگر نیاز به نگهداری Session باشد: Session Affinity (چسبندگی Session به یک سرور خاص در Load Balancer) ا Sticky Session فراموش نشود.
- راهکارهای مختلف مدیریت سشن:

  - Stateless → نیازی به Session نیست.
  - Stateful → نیاز به مدیریت Session داریم: ذخیره Session در Redis (Redis Session Store) یا استفاده از Database (گزینه ضعیف‌تر نسبت به Redis)
- بهینه سازی سامانه:

  - استفاده از Connection Pool برای دیتابیس
  - داشتن Read Replicas برای افزایش سرعت Queryها
  - استفاده از Async Tasks و Queue برای Taskهای سنگین
  - طراحی Optimal Queue Per-Long Task
  - استفاده از Reactive / Caching برای بهبود Performance
  - مدیریت امنیتی با: Encrypting & Secure Cookies برای Session
- جمعبندی:

  - تا جای ممکن Stateless باشد.
  - Session را بیرون از سرور اپلیکیشن ذخیره کند (Redis → بهترین گزینه).
  - از Load Balancer هوشمند با Session Affinity استفاده کند اگر Stateless ممکن نبود.
  - دیتابیس را بهینه کند (Connection Pool, Read Replicas).
  - وظایف سنگین را Async و در Queue قرار دهد.
  - تنظیمات را بیرون از کد نگه دارد (Externalized Config).
  - از اصول معماری شی‌گرا و الگوهای طراحی (Factory, Strategy, Observer, Template) بهره بگیرد.

## Index in Database

- ایندکس یک ساختار داده است که برای سرعت بخشیدن به جستجو و کوئری‌ها در جدول‌های پایگاه داده استفاده می‌شود. کارکردهای اصلی ایندکس:

  - کاهش زمان اجرای جستجو (Search) در جدول.
  - بهبود عملکرد در کوئری‌هایی که دارای WHERE, ORDER BY, JOIN هستند.
  - نگهداری اشاره‌گرها به رکوردهای واقعی.
  - ایندکس‌ها بعد از هر عملیات INSERT, UPDATE, DELETE باید به‌روز شوند.
  - استفاده از ایندکس روی ستون‌هایی که زیاد در شرط‌های جستجو استفاده می‌شوند.
  - در جداول بزرگ بسیار کاربردی است، اما روی جداول کوچک ممکن است کارایی خاصی نداشته باشد.
  - ایندکس‌ها می‌توانند روی یک یا چند ستون تعریف شوند (Single Column Index و Composite Index).
  - نوع خاصی از ایندکس وجود دارد که به نام Unique Index شناخته می‌شود و از تکرار داده جلوگیری می‌کند.
- ایندکس سرعت خواندن داده را افزایش می‌دهد ولی سرعت نوشتن (Insert/Update/Delete) را کاهش می‌دهد. انتخاب هوشمندانه ستون‌ها برای ایندکس‌گذاری حیاتی است. معیارهای انتخاب هوشمندانه ستون برای ایندکس:

  - ستونی که در شرط‌های WHERE زیاد استفاده می‌شود (خصوصاً ستون‌هایی با عملگرهای =، >، <، BETWEEN، IN).
  - ستونی که در عبارت‌های JOIN برای اتصال جداول استفاده می‌شود.
  - ستونی که در ORDER BY و GROUP BY زیاد تکرار می‌شود.
  - ستونی که کاراکتر انتخابی (Selectivity) بالایی دارد؛ یعنی تعداد مقادیر یکتا (Distinct) آن نسبت به کل رکوردها زیاد باشد.
  - ستونی که اغلب در Queryهای پرتکرار استفاده می‌شود و سرعت گرفتن داده در آن اهمیت بالایی دارد.
  - ستونی که اندازه آن کوچک است (مثل int یا short به‌جای text یا blob) چون ایندکس روی ستون‌های حجیم کارایی کمتری دارد.
  - ستون‌های ترکیبی (Composite Index) زمانی که جستجو اغلب روی چند ستون باهم انجام می‌شود.
  - ستون‌هایی که مرتب‌سازی یا فیلتر روی آن‌ها بار سنگینی دارد و Bottleneck ایجاد می‌کنند.
- چه زمانی ایندکس استفاده نکنیم؟

  - زمانی که جدول خیلی کوچک است (مثلاً چند صد ردیف) و جستجو روی آن سریع انجام می‌شود.
  - روی ستون‌هایی که مقادیرشان تکراری و یکنواخت هستند (مثل ستون جنسیت با مقادیر Male/Female).
  - روی ستون‌هایی که زیاد آپدیت یا اینسرت می‌شوند چون نگهداری ایندکس سربار سنگینی دارد.
  - روی ستون‌هایی با نوع داده بزرگ (مثل TEXT یا BLOB) که ایندکس‌گذاری روی آن‌ها هزینه‌بر است.
  - زمانی که کوئری‌ها معمولاً همه رکوردها را اسکن می‌کنند (Full Table Scan)، مثل گزارش‌گیری آماری روی کل داده.
  - در جداولی که عملیات نوشتن (Insert/Update/Delete) بسیار بیشتر از خواندن است، چون ایندکس سرعت نوشتن را کاهش می‌دهد.
  - وقتی که ایندکس زیاد باعث افزایش حجم دیتابیس و مصرف بالای حافظه شود.
  - روی ستون‌هایی که مرتب در query فقط در بخش select ظاهر می‌شوند اما در شرط یا join استفاده نمی‌شوند.
- راهکارهای طراحی پایگاه داده برای سامانه های با بار بالا (High Load System)

  - نرمال‌سازی جداول تا جای ممکن برای جلوگیری از افزونگی و ناسازگاری داده
  - دنرمال‌سازی در جاهایی که نیاز به سرعت بیشتر خواندن وجود دارد (مثل گزارش‌گیری و کوئری‌های پرتکرار)
  - استفاده هوشمندانه از ایندکس روی ستون‌هایی که در شرط‌ها، join یا order by زیاد استفاده می‌شوند
  - اجتناب از ایندکس روی ستون‌هایی که تغییرات مکرر دارند یا مقدارشان تکراری است
  - استفاده از پارتیشن‌بندی (Partitioning) برای تقسیم جداول بزرگ بر اساس تاریخ، محدوده عددی یا کلید مشخص
  - به‌کارگیری شاردینگ (Sharding) برای توزیع بار روی چند دیتابیس مجزا در سامانه‌های بسیار بزرگ
  - کش کردن داده‌های پرتکرار در سطوح مختلف (Cache سمت اپلیکیشن یا کش توکار دیتابیس)
  - طراحی صحیح کلیدهای اصلی (Primary Key)؛ مثلاً اجتناب از کلیدهای خیلی بزرگ یا ترکیبی پیچیده
  - استفاده از نوع داده مناسب و کوچک‌تر برای کاهش حجم ذخیره‌سازی و افزایش سرعت جستجو
  - بهینه‌سازی queryها با بازنویسی دستورات SQL و اجتناب از کوئری‌های پیچیده و تو در تو
  - طراحی ایندکس‌های ترکیبی (Composite Index) برای پوشش بهتر کوئری‌های چندستونی
  - اجتناب از جداول با قفل زیاد (Table Locking) و استفاده از تکنیک‌هایی مثل row-level locking
  - آرشیو کردن داده‌های قدیمی در جداول یا دیتابیس جدا برای سبک نگه داشتن جداول عملیاتی

## Singleton problem in Multi-thread environment

- سینگلتون (Singleton) الگویی در طراحی نرم‌افزار است که هدفش این است یک کلاس فقط یک نمونه (instance) در طول اجرای برنامه داشته باشد و دسترسی سراسری (global) به آن نمونه فراهم شود.
- مثال ساده در جاوا:

<div dir="ltr">

```

public class Singleton {

    private static Singleton instance;

    private Singleton() {

        // جلوگیری از ساخت نمونه از بیرون

    }

    public static Singleton getInstance() {

        if (instance == null) {

            instance = new Singleton(); // ساخت نمونه در اولین دسترسی

        }

        return instance;

    }

}

```

</div>

- در مثال بالا، اگر دو ترد (Thread) همزمان به متد getInstance() دسترسی پیدا کنند، هر دو شرط if (instance == null) را true می‌بینند. در نتیجه هر دو ترد نمونه جدید می‌سازند و چندین instance ساخته می‌شود که با هدف سینگلتون در تضاد است.
- یک راه حل استفاده از synchronized برای متد getInstance

  - کل متد getInstance() را synchronized می‌کنیم. این روش مشکل چندنخی را حل می‌کند ولی هزینه زیادی دارد چون هر بار گرفتن instance نیازمند lock است.

<div dir="ltr">

```

public class Singleton {

    private static Singleton instance;

    private Singleton() {}

    public static synchronized Singleton getInstance() {

        if (instance == null) {

            instance = new Singleton();

        }

        return instance;

    }

}

```

</div>

- Double Checked Locking (بررسی دو مرحله‌ای)

  - در این روش ابتدا چک می‌کنیم اگر instance برابر null بود وارد بلاک synchronized شویم.
  - داخل بلاک دوباره چک می‌کنیم اگر باز هم null بود نمونه ساخته شود.
  - برای جلوگیری از مشکلات حافظه کش CPU باید instance را volatile تعریف کنیم. این روش پرکاربرد است چون فقط هنگام ساخت اولین بار قفل می‌گیرد. وقتی یک متغیر با volatile تعریف شود، هربار که یک نخ بخواهد آن راه بخواند مستقیما از حافظه اصلی خوانده می شود (نه کش مربوط به آن نخ در CPU) ثانیا هربار نخی بخواهد آن راه تغییر دهد بلافاصله مقدار در حافظه اصلی مینشیند و نه کش.

<div dir="ltr">

```

public class Singleton {

    private static volatile Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {

        if (instance == null) { // چک اول

            synchronized (Singleton.class) {

                if (instance == null) { // چک دوم

                    instance = new Singleton();

                }

            }

        }

        return instance;

    }

}

```

</div>

- استفاده از Holder Class (راه‌حل تنبل و امن)

  - یک کلاس داخلی استاتیک تعریف می‌کنیم که instance را نگه دارد.
  - فقط زمانی که به getInstance() دسترسی شود کلاس Holder بارگذاری و نمونه ساخته می‌شود.
  - این روش هم thread-safe است و هم کارایی بالایی دارد.
  - بدون نیاز به synchronized است و با استفاده از مکانیز lazy-loading در JVM کار میکند.

<div dir="ltr">

```

public class Singleton {

    private Singleton() {}

    private static class Holder {

        private static final Singleton INSTANCE = new Singleton();

    }

    public static Singleton getInstance() {

        return Holder.INSTANCE;

    }

}

```

</div>

- استفاده از Enum برای Singleton

  - تعریف یک enum با یک مقدار ثابت (INSTANCE).
  - جاوا تضمین می‌کند enum در برابر serialization و reflection ایمن است.
  - این روش بهترین و ساده‌ترین پیاده‌سازی سینگلتون است.

<div dir="ltr">

```

public enum Singleton {

    INSTANCE;

    public void doSomething() {

        System.out.println("Doing something...");

    }

}

```

</div>

- نکات مهم

  - synchronized ساده ساده‌ترین ولی کندترین روش است.
  - double checked locking نیازمند volatile است تا از reorder شدن دستورات جلوگیری کند.
  - روش holder class و enum هم thread-safe هستند و کارایی بالاتری دارند.
  - enum تنها روشی است که در برابر reflection و serialization هم ایمن است.
  - Serialization: برای enum ها جاوا همیشه همان instance موجود را برمی‌گرداند، حتی اگر فایل serialized را بخوانی. یعنی new ساخته نمی‌شود.
  - Reflection: سازنده enum به صورت پیش‌فرض private است و JVM اجازه نمی‌دهد با reflection نمونه جدیدی از آن بسازی.
- خلاصه

  - اگر دنبال ساده‌ترین راه هستی → synchronized
  - اگر دنبال عملکرد بهتر هستی → Double-Checked Locking
  - اگر دنبال راه استاندارد و مدرن هستی → Holder idiom یا Enum

## Serialization in distributed environment

- Serialization فرایندی است که در آن یک شیء در حافظه به یک قالب قابل انتقال یا ذخیره‌سازی (مثل بایت‌ها، JSON یا Protobuf) تبدیل می‌شود.
- Deserialization عمل معکوس آن است، یعنی بازسازی شیء اصلی از داده‌های سریال‌شده.
- کاربردها:

  - ذخیره وضعیت اشیاء در فایل یا پایگاه‌داده
  - انتقال داده بین سرویس‌ها در شبکه
  - ارسال پیام در سیستم‌های توزیع‌شده (مثلا Kafka، RabbitMQ)
  - برقراری ارتباط بین زبان‌ها و پلتفرم‌های مختلف
- اصول Serialization در محیط توزیع شده

  - سازگاری نسخه‌ها (Version Compatibility) در سیستم‌های توزیع‌شده ممکنه کلاینت و سرور از نسخه‌های متفاوتی از کلاس استفاده کنن.
  - استفاده از serialVersionUID یا طراحی backward-compatible خیلی مهمه.
  - قابلیت حمل (Portability) داده باید بین زبان‌ها و پلتفرم‌های مختلف رد و بدل بشه. برای همین معمولاً به‌جای Java Native Serialization از فرمت‌های استانداردتر مثل JSON, Avro, Protobuf, Thrift استفاده می‌کنن.
  - امنیت (Security) جلوگیری از deserialization attack مثل RCE (Remote Code Execution). هرگز به داده‌های ناشناس اجازه‌ی deserialize مستقیم نده.
  - کارایی (Performance & Efficiency) در توزیع‌شده‌ها حجم داده و latency خیلی مهمه. Protobuf یا Avro نسبت به JSON/XML کاراتر هستن (فشرده‌تر و سریع‌تر).
  - قابلیت تکامل (Schema Evolution) باید بشه فیلد جدید اضافه کرد بدون اینکه کل سیستم از کار بیفته. ابزارهایی مثل Avro Schema و Protobuf Schema این مشکل رو حل می‌کنن.
  - استفاده از Serialization Proxy Pattern در جاوا برای جلوگیری از مشکلات امنیتی و کنترل بهتر، به‌خصوص وقتی کلاس‌ها در شبکه منتقل می‌شن.
- جدول مقایسه روش ها


| **ویژگی‌ها**                                      | **Java Native Serialization**                    | **JSON**                                          | **Protobuf**                                       | **Avro**                                                      |
| ----------------------------------------------------------- | -------------------------------------------------- | --------------------------------------------------- | ---------------------------------------------------- | --------------------------------------------------------------- |
| خوانایی انسانی                               | ندارد                                       | دارد                                          | ندارد                                         | ندارد                                                    |
| کارایی (سرعت و حجم داده)                | ضعیف (حجم زیاد، سرعت پایین) | متوسط (متن‌محور)                     | بسیار بالا (باینری فشرده)      | بالا (باینری فشرده)                            |
| پشتیبانی بین زبان‌ها                    | فقط جاوا                                  | همه زبان‌ها                             | همه زبان‌ها                              | همه زبان‌ها                                         |
| تکامل Schema (Schema Evolution)                      | ضعیف (با نسخه‌ها می‌شکند)    | دستی باید مدیریت شود             | عالی (پشتیبانی از optional/required) | عالی (Schema همراه داده ذخیره می‌شود) |
| امنیت در برابر Deserialization Attack         | ضعیف (آسیب‌پذیر)                    | امن‌تر                                      | امن‌تر                                       | امن‌تر                                                  |
| سادگی در Debug و Log                              | سخت                                           | خیلی ساده (متن‌محور)              | سخت (باینری)                              | نیمه‌ساده (نیاز به schema)                     |
| مناسب برای سیستم‌های توزیع‌شده | خیر                                           | برای ارتباط ساده و REST مناسب | عالی (Microservices, gRPC)                     | عالی (Big Data, Streaming)                                |
| موارد استفاده متداول                    | سیستم‌های قدیمی جاوا           | REST API، وب‌سرویس‌ها                 | gRPC، میکروسرویس‌ها، موبایل   | Hadoop، Kafka، Big Data                                     |

## Techniuqes for Resource Management and Concurrency in Java

- Thread Pool و Executors

  - استفاده از ThreadPool برای مدیریت بهینه منابع پردازشی
  - استفاده از Executors برای ایجاد و مدیریت نخ‌ها
- Synchronization و Locks

  - استفاده از synchronized
  - استفاده از ReentrantLock برای کنترل دقیق‌تر قفل‌ها
- Concurrent Collections

  - استفاده از ConcurrentHashMap به جای HashMap در محیط چندنخی
  - استفاده از CopyOnWriteArrayList به جای ArrayList در محیط چندنخی
  - استفاده از BlockingQueue برای صف‌های thread-safe
- Atomic Variables

  - استفاده از کلاس‌های اتمیک مثل:
  - AtomicInteger
  - AtomicLong
  - AtomicBoolean
  - برای انجام عملیات thread-safe بدون نیاز به قفل
- ThreadLocal Storage

  - نگهداری داده‌های خاص هر نخ به‌طور مجزا با استفاده از ThreadLocal
- Immutable Objects

  - طراحی اشیای تغییرناپذیر برای کاهش مشکلات همزمانی
  - مثال: استفاده از کلاس‌های immutable مثل String در جاوا
- Fork/Join Framework و Work Stealing

  - استفاده از فریمورک Fork/Join برای پردازش موازی وظایف بزرگ
  - استفاده از الگوریتم Work Stealing برای توزیع بهتر بار پردازشی
- Reactive Programming

  - استفاده از برنامه‌نویسی reactive برای مدیریت بهتر جریان داده و منابع در محیط‌های همزمان و با نیاز به مقیاس پذیری خیلی بالا

</div>
