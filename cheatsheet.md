اصول طراحی در مهندسی نرم افزار:

- قانون Kiss (Keep It Simple, Stupid):

  - کدت رو ساده نگه‌دار و زیاد پیچیدش نکن.
  - کد باید تا حد امکان ساده نوشته بشه تا راحت فهمیده، تست، نگهداری و گسترش داده بشه.
  - توابع کوچک داشته باش. هر تابع باید فقط یک کار انجام بده.
  - از شرط‌های تودرتو پرهیز کن و شرط‌های ساده و واضح بنویس.
  - از متغیر اضافی پرهیز کن. متغیر اضافی پیچیدگی اضافی بهت تحمیل می‌کنه.
  - کد ساده‌تر تست پذیری راحت‌تری هم داره.
  - نام گذاری ها واضح باشن. اسم خوب خودش نصف توضیحاته.
  - در کل بدون هر کسی میتونه کد پیچیده‌ای بنویسه که کار میکنه مهم اینه کدی بنویسی که هم ساده باشه هم کار کنه.

    - قانون DRY (Don’t Repeat Yourself):
    - از تکرار کد خودداری کن.
    - تکرار = دردسر در نگهداری

      - در کل بهتره یک تابع یا کلاس مشترک بسازی
      - قانون YAGNI (You Are’nt Gonna Need It)":
      - چیزی رو که الان نیاز نداری اضافه نکن.
      - این که بگی شاید بعدا لازم شد = کد اضافی = پیچیدگی بیشتر
      - فقط چیزی رو بساز که واقعا لازم داری
    - قانون TDA (Tell, Don’t Ask):
    - به جای این که از شی چیزی بپرسی و بعد تصمیم بگیری، تصمیم رو به خودش بسپار و ازش کاری که میخوای انجام بده رو بخواه.
    - یه مثال:

      if (car.getFuelLevel() > 0) {

      car.drive();

      } //Wrong way

car.drive(); //Correct way

- قانون SOLID (Single responsibility, Opne/Closed, Liskov substitution, Interface Segregation, Dependency Injection):

  - S: Single Responsibility  هر کلاس باید فقط یک وظیفه داشته باشد. مثال احراز هویت و ریپازیتوری در یک کلاس
  - O: Open/Closed  کلاس‌ها باید برای توسعه باز و برای تغییر بسته باشند. مثال مستطیل و اضافه شدن دایره برای محاسبه مساحت.
  - L: Liskov Substitution اشیاء فرزند باید قابل جایگزینی با والد باشند. مثال پرنده و پنگوئن.
  - I: Interface Segregation نباید مجبور به پیاده‌سازی متدهایی شویم که نیاز نداریم. مثال کارگر که هم ربات پیاده ش کنه هم انسان (کار کردن و خوردن)
  - D: Dependency Inversion وابستگی‌ها باید به abstraction باشد، نه پیاده‌سازی. مثال وابستگی سوییچ به لامپ. باید به دیوایس وابسته باشه.
  - قانون GRASP (General Reponsibility Assignment Software Pattern):
  - این قوانین الگوهای کلی برای واگذاری مسئولیت‌ها در طراحی شی گرا هستند.

    - این اصول به ما کمک میکنند تصمیم بگیریم کدام کلاس/شی باید چه مسئولیتی داشته باشد.
    - درواقع SOLID میگه چطور طراحی کنیم و GRASP میگه چه کسی (شی/کلاس) چیکار کنه.
    - شامل موارد زیر هست:

      	Information Expert: کلاسی مسئولیت رو بگیره که بیشترین اطلاعات مرتبط رو داره. مثلا کلاس Invoice باید جمع قیمت آیتم هارو محاسبه کنه چون خودش به آیتم ها دسترسی داره.

      	Creator: کلاسی شیء جدید بسازی که با اون رابطه نزدیک داره. مثلا کلاس Order بیاد OrderItem بسازه چون هر Order شامل OrderItemها هست.

      	Controller: کلاس بین UI و جدول هست که ورودی‌ها رو کنترل میکنه. مثلا در MVC میتونیم OrderController داشته باشیم.

      	Low Coupling: وابستگی بین کلاس‌ها باید تا جای ممکن کم باشه. مثلا به جای این که کلاس A مستقیما کلاس B رو بسازی، از Factory یا Dependenci Injection استفاده کنه.

      	High Cohision: هر کلاسی باید یه کار مشخص تمیز داشته باشه. کلاسی که کارهای پراکنده میکنه قابل نگهداری نیست.

      	Polymorphism: به معنای داشتن رفتار متفاوت با استفاه از Interface هست. مثلا میتونیم از Animal به عنوان اینترفیس استفاده کنیم که تابع Speak داره و بعد سگ و گربه اون رو پیاده میکنند.

      	Pure Fabrication: یک کلاس مصنوعی بساز فقط برای رعایت بقیه اصول. مثلا repository برای جدا کردن دسترسی به دیتابیس در مدل اصلی.

      	Indirection: ایجاد یک واسطه برای کاهش وابستگی سیستم. مثلا استفاده از سرویس یا اینترفیس بین Controller و Data Access

      	Protected Variations: نقاطی که ممکنه تغییر کنند رو با abstraction بپوشون. مثلا استفاده از اینترفیس برای لایه دیتابیس چون ممکنه نوع دیتابیس عوض بشه.پ

      ORMها یا Object Relational Mapping:
- تبدیل خودکار بین اشیاء برنامه (Objects) و جداول پایگاه داده (Relational Table) را انجام می‌دهد.
- یک ابزار یا به عبارتی یک کتابخانه است که کمک می‌کند به جای نوشتن مستقیم SQL خام، از طریق کلاس‌ها و اشیاء جاوا با دیتابیس کار کنیم.
- معروف تریم ORM در جاوا Hibernate است.
- JPA هم یک استاندارد جاوا برای ORM است و هایبرنیت به عبارتی یکی از پیاده سازی های JPA  است.
- Spring Data JPA هم یک ابسترکت بالاتر روی JPA است و برای راحتی بیشتر است. کار راه راحت تر و امن تر کرده و قابلیت نگهداری را افزایش می دهد اما برای کوئری های پیچیده بهتر است از SQL استفاده شود.

  - انواع کارکردها و نیازهاشون:
  - برای CRUD ساده و معمولی: ORM عالیه

    - برای پروژه های بزرگ و تیمی: ORM برای نگهداری بهتره
    - در صورت نیاز به پرفورمنس بالا: SQL خام در برخی بخش‌های خاص بهتره
    - برای گزارش‌گیری سنگین و پیچیده: SQL یا Stored Procedure مفید تره

      	نمونه SP:

      @NamedStoredProcedureQuery(

      name = "getEmployeesByDepartment",

      procedureName = "GET_EMPLOYEES_BY_DEPT",

      parameters = {

      @StoredProcedureParameter(mode = ParameterMode.IN, name = "deptId", type = Integer.class)

      },

      resultClasses = Employee.class

      )

      @Entity

      public class Employee {

      // ...

      }

      و سپس در کد:

      StoredProcedureQuery query = entityManager

      .createNamedStoredProcedureQuery("getEmployeesByDepartment")

      .setParameter("deptId", 10);

      List<Employee> employees = query.getResultList();
    - Annotationهای پایه در هایبرنیت برای نگاشت کلاس به جدول:
    - @Entity: کلاس نماینده یک جدول است.
    - @Table: نام جدول رو در دیتابیس مشخص میکند.

      - @Id: مشخص کننده کلید اصلی یا همان Primary Key است.
      - @GeneratedValue: نحوه تولید مقدار کلید اصلی را مشخص می‌کند.
      - @Column: نام یک ستون خاص در جدول را مشخص میکند.
    - Annotationهای پایه برای نگاشت روابط بین جداول (ارتباط بین کلاس‌ها):
    - برای روابط یک به یک، یک به چند و چند به یک @JoinColumn که ستون کلید خارجی را مشخص میکند.
    - برای روابط چند به چنتد @JoinTable که جدول واسط را مشخص میکند.

      - Annotationهای مربوط به ویژگی ستون‌ها:
      - @Column مشخص می‌کند که یک فیلد به یک ستون در جدول پایگاه داده نگاشت شود. قابلیت تنظیم ویژگی‌هایی مثل name, nullable, length, unique و columnDefinition را دارد.

        @Column(name = "first_name", nullable = false, length = 50)

        private String firstName;
      - @Temporal فقط برای فیلدهای نوع java.util.Date یا Calendar استفاده می‌شود. تعیین می‌کند که کدام بخش از زمان (تاریخ/ساعت/هر دو) در پایگاه داده ذخیره شود. مقادیر ممکن: TemporalType.DATE, TemporalType.TIME, TemporalType.TIMESTAMP.

        @Temporal(TemporalType.DATE)

        private Date birthDate;
      - @Lob برای فیلدهایی با حجم بالا استفاده می‌شود (مثل متن‌های طولانی یا داده‌های باینری). متن بزرگ (CLOB) یا داده باینری بزرگ (BLOB) را مشخص می‌کند.

        @Lob

        private String longText;


@Lob

private byte[] imageData;

- @Transient این فیلد در پایگاه داده ذخیره نمی‌شود. برای داده‌هایی استفاده می‌شود که فقط در حافظه نگهداری می‌شوند (مثلاً برای محاسبات موقت). مشابه transient در جاوا ولی مخصوص JPA است.

@Transient

private String tempDisplayName;


- نحوه کار به این صورته که زمانی که هایبرنیت شروع به کار میکنه، کلاس هایی که انوتیشن @Entity دارند رو شناسایی میکنه . براشون جدول معادل در دیتابیس ایجاد میکنه (در صورت استفاده از auto-schema-generator) اطلاعات موجود در جدول رو به شیء جاوا و برعکس نگاشت میکنه.

  مقایسه کلید اولیه یا Primary Key با کلید خارجی یا Foreign Key:

---

ویژگی|    PF   |     PK      |
---
